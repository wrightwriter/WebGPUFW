(()=>{var __webpack_modules__={563:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, "body {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  width: 100vw;\\r\\n  height: 100vh;\\r\\n  overflow: hidden;\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  background-color: black;\\r\\n}\\r\\n\\r\\ncanvas {\\r\\n  /* max-width: 100%;\\r\\n  max-height: 100%; */\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n}\\r\\n#canvas{\\r\\n  /* opacity: 0; */\\r\\n  /* pointer-events: none; */\\r\\n  /* position: absolute; */\\r\\n  /* width: 100%;\\r\\n  height: 100%; */\\r\\n}\\r\\n", ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://webgpufw/./public/style.css?./node_modules/css-loader/dist/cjs.js')},645:module=>{eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += "}";\n      }\n\n      if (item[2]) {\n        content += "}";\n      }\n\n      if (item[4]) {\n        content += "}";\n      }\n\n      return content;\n    }).join("");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://webgpufw/./node_modules/css-loader/dist/runtime/api.js?')},81:module=>{eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://webgpufw/./node_modules/css-loader/dist/runtime/noSourceMaps.js?")},115:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\\r\\nstruct VSOut {\\r\\n  @builtin(position) Position: v4,\\r\\n  @location(0) uv: v2,\\r\\n}\\r\\n\\r\\n\\r\\n@vertex\\r\\nfn main(\\r\\n  @location(0) inPos: v2,\\r\\n) -> VSOut {\\r\\n  var O: VSOut;\\r\\n\\r\\n  // O.Position = v4(z + v3(0.,0.,0.), 1.);\\r\\n  O.Position = v4(inPos.xy, 0., 1.) ;\\r\\n\\r\\n  // O.col = inCol;\\r\\n  O.uv = inPos.xy;\\r\\n\\r\\n  return O;\\r\\n}");\n\n//# sourceURL=webpack://webgpufw/./src/shaders/fullscreenQuad.wgsl?')},431:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\\r\\n\\r\\nconst pos = array<v2, 3>(\\r\\n  v2(0.0, 0.5),\\r\\n  v2(-0.5, -0.5),\\r\\n  v2(0.5, -0.5));\\r\\n\\r\\n// [[location(0)]] var<in> a_pos : vec2<f32>;\\r\\n// [[location(1)]] var<in> a_uv : vec2<f32>;\\r\\n\\r\\n// [[location(0)]] var<out> vUV : vec2<f32>;\\r\\n\\r\\n// [[builtin(position)]] var<out> Position : vec4<f32>;\\r\\n// [[builtin(vertex_index)]] var<in> VertexIndex : i32;\\r\\n\\r\\n\\r\\nstruct VSOut {\\r\\n  @builtin(position) Position: v4,\\r\\n  @location(0) col: v4,\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn main(\\r\\n  @location(0) inPos: v4,\\r\\n  @location(1) inCol: v4,\\r\\n  @builtin(vertex_index) VertexIndex: u32\\r\\n) -> VSOut {\\r\\n  var O: VSOut;\\r\\n\\r\\n  O.Position = v4(inPos.xyz + v3(0.,0.,0.), 1.);\\r\\n  // O.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\\r\\n  // O.Position = cam.proj * O.Position ;\\r\\n  // O.Position = viewMat * O.Position ;\\r\\n  O.Position = cam.proj * cam.view * O.Position ;\\r\\n  O.col = inCol;\\r\\n\\r\\n  return O;\\r\\n}");\n\n//# sourceURL=webpack://webgpufw/./src/shaders/passthroughVert.wgsl?')},280:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(379);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(795);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(569);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(565);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(216);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(589);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(563);\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z, options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__/* ["default"].locals */ .Z.locals : undefined);\n\n\n//# sourceURL=webpack://webgpufw/./public/style.css?')},379:module=>{eval('\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?')},569:module=>{eval('\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/insertBySelector.js?')},216:module=>{eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/insertStyleElement.js?')},565:(module,__unused_webpack_exports,__webpack_require__)=>{eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?')},795:module=>{eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n\n  var needLayer = typeof obj.layer !== "undefined";\n\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += "}";\n  }\n\n  if (obj.media) {\n    css += "}";\n  }\n\n  if (obj.supports) {\n    css += "}";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/styleDomAPI.js?')},589:module=>{eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://webgpufw/./node_modules/style-loader/dist/runtime/styleTagTransform.js?")},42:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "v": () => (/* binding */ Sketch)\n});\n\n;// CONCATENATED MODULE: ./src/utils/wmath.ts\nconst tau = Math.PI * 2.0;\r\nconst pi = Math.PI;\r\nconst halfPi = Math.PI / 2;\r\nfunction max(a, b) {\r\n    return Math.max(a, b);\r\n}\r\nconst r2pi = 0.63661977236;\r\nconst nkingSin = (x) => {\r\n    const xtau = x * tau;\r\n    if ((xtau - Math.floor(xtau)) > pi) {\r\n        const mod = (x - pi) * r2pi - 1;\r\n        return mod * mod - 1;\r\n    }\r\n    else {\r\n        const mod = x * r2pi - 1;\r\n        return 1 - mod * mod;\r\n    }\r\n};\r\nconst smoothsin = (x) => {\r\n    const b = x * x * (3.0 - 2.0 * x);\r\n    const a = x * (3 - 1.0 * x);\r\n    return a + (b - a) * b;\r\n};\r\nconst oneOverHalfPi = 1 / (pi / 2);\r\nconst fastSin = (x) => {\r\n    x *= oneOverHalfPi;\r\n    const id = Math.floor(x);\r\n    x = x % 1;\r\n    let side = 1;\r\n    if ((id - 2) % 4 < 2) {\r\n        side = -1;\r\n    }\r\n    if (id % 2 === 1) {\r\n        x = 1 - x;\r\n    }\r\n    let approx = smoothsin(x);\r\n    approx *= side;\r\n    return approx;\r\n};\r\nfunction quantize(a, b) {\r\n    return Math.floor(a / b) * b;\r\n}\r\nfunction dmod(a, b, c = 2) {\r\n    return max(mod(a, b) - b + 2, 0);\r\n}\r\nfunction abs(a) {\r\n    return Math.abs(a);\r\n}\r\nfunction tri(a) {\r\n    const fr = a - Math.floor(a);\r\n    return abs(fr - 0.5) * 2. - 1;\r\n}\r\nfunction floor(a) {\r\n    return Math.floor(a);\r\n}\r\nfunction ceil(a) {\r\n    return Math.ceil(a);\r\n}\r\nfunction pow(a, b) {\r\n    return Math.pow(a, b);\r\n}\r\nfunction wrap(a, from, to) {\r\n    const range = to - from;\r\n    a -= from;\r\n    a = mod(a, range);\r\n    return from + a;\r\n}\r\nfunction fract(a) {\r\n    return mod(a, 1);\r\n}\r\nconst lerp = (a, b, x) => a + (b - a) * x;\r\nconst clamp = (x, l, h) => Math.min(Math.max(x, l), h);\r\nconst saturate = (x) => Math.min(Math.max(x, 0.0), 1.0);\r\nconst linearstep = (a, b, x) => saturate((x - a) / (b - a));\r\nconst wmath_smoothstep = (a, b, x) => {\r\n    const t = linearstep(a, b, x);\r\n    return t * t * (3.0 - 2.0 * t);\r\n};\r\nclass Hash {\r\n    static h11(p) {\r\n        p = fract(p * .1031);\r\n        p *= p + 33.33;\r\n        p *= p + p;\r\n        return fract(p);\r\n    }\r\n}\r\nfunction valueNoise(a) {\r\n    const fla = floor(a);\r\n    const ceila = fla + 1;\r\n    const rcurr = Hash.h11(fla);\r\n    const rnext = Hash.h11(ceila);\r\n    let fr = fract(a);\r\n    fr = wmath_smoothstep(0., 1., fr);\r\n    return lerp(rcurr, rnext, fr);\r\n}\r\nfunction valueNoisePow(a, b) {\r\n    const fla = floor(a);\r\n    const ceila = fla + 1;\r\n    const rcurr = Hash.h11(fla);\r\n    const rnext = Hash.h11(ceila);\r\n    let fr = fract(a);\r\n    fr = wmath_smoothstep(0., 1., fr);\r\n    fr = pow(fr, b);\r\n    return lerp(rcurr, rnext, fr);\r\n}\r\nfunction rand() { return Math.random(); }\r\nclass Ease {\r\n    static linear(t) {\r\n        return 0;\r\n    }\r\n    static easeInQuad(t) {\r\n        return t * t;\r\n    }\r\n    static easeOutQuad(t) {\r\n        return t * (2 - t);\r\n    }\r\n    static easeInOutQuad(t) {\r\n        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n    }\r\n    static easeInCubic(t) {\r\n        return t * t * t;\r\n    }\r\n    static easeOutCubic(t) {\r\n        return --t * t * t + 1;\r\n    }\r\n    static easeInOutCubic(t) {\r\n        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n    }\r\n    static easeInQuart(t) {\r\n        return t * t * t * t;\r\n    }\r\n    static easeOutQuart(t) {\r\n        return 1 - --t * t * t * t;\r\n    }\r\n    static easeInOutQuart(t) {\r\n        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\r\n    }\r\n    static easeInQuint(t) {\r\n        return t * t * t * t * t;\r\n    }\r\n    static easeOutQuint(t) {\r\n        return 1 + --t * t * t * t * t;\r\n    }\r\n    static easeInOutQuint(t) {\r\n        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\r\n    }\r\n    static easeInElastic(t) {\r\n        const c4 = (2 * Math.PI) / 3;\r\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\r\n    }\r\n    static easeOutElastic(t) {\r\n        const c4 = (2 * Math.PI) / 3;\r\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\r\n    }\r\n}\r\nfunction cos(a) { return Math.cos(a); }\r\n;\r\nfunction sin(a) { return Math.sin(a); }\r\n;\r\nfunction acos(a) { return Math.acos(a); }\r\n;\r\nfunction asin(a) { return Math.asin(a); }\r\n;\r\nfunction sqrt(a) { return Math.sqrt(a); }\r\n;\r\nfunction mod(n, m) { return ((n % m) + m) % m; }\r\nclass ArrVec {\r\n    static sub(arr, val) {\r\n        for (let idxArr = 0; idxArr < arr.length; idxArr++) {\r\n            if (typeof val == "object") {\r\n                arr[idxArr] -= val[idxArr];\r\n            }\r\n            else {\r\n                arr[idxArr] -= val;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    static div(arr, val) {\r\n        for (let idxArr = 0; idxArr < arr.length; idxArr++) {\r\n            if (typeof val == "object") {\r\n                arr[idxArr] /= val[idxArr];\r\n            }\r\n            else {\r\n                arr[idxArr] /= val;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    static mul(arr, val) {\r\n        for (let idxArr = 0; idxArr < arr.length; idxArr++) {\r\n            if (typeof val == "object") {\r\n                arr[idxArr] *= val[idxArr];\r\n            }\r\n            else {\r\n                arr[idxArr] *= val;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    static add(arr, val) {\r\n        for (let idxArr = 0; idxArr < arr.length; idxArr++) {\r\n            if (typeof val == "object") {\r\n                arr[idxArr] += val[idxArr];\r\n            }\r\n            else {\r\n                arr[idxArr] += val;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n}\r\nclass Vec {\r\n    constructor(a, b) {\r\n        if (a == NaN || b == undefined)\r\n            throw "num error";\r\n        this.v = [];\r\n        this.v[0] = a;\r\n        this.v[1] = b;\r\n    }\r\n    setX(a) { this.v[0] = a; }\r\n    ;\r\n    setY(a) { this.v[1] = a; }\r\n    ;\r\n    get x() { return this.v[0]; }\r\n    ;\r\n    get y() { return this.v[1]; }\r\n    ;\r\n    mul(b) {\r\n        if (typeof b == "object") {\r\n            return new Vec(this.v[0] * b.v[0], this.v[1] * b.v[1]);\r\n        }\r\n        else {\r\n            return new Vec(this.v[0] * b, this.v[1] * b);\r\n        }\r\n    }\r\n    ;\r\n    div(b) {\r\n        if (typeof b == "object")\r\n            return new Vec(this.v[0] / b.v[0], this.v[1] / b.v[1]);\r\n        else\r\n            return new Vec(this.v[0] / b, this.v[1] / b);\r\n    }\r\n    ;\r\n    add(b) {\r\n        if (typeof b == "object")\r\n            return new Vec(this.v[0] + b.v[0], this.v[1] + b.v[1]);\r\n        else\r\n            return new Vec(this.v[0] + b, this.v[1] + b);\r\n    }\r\n    ;\r\n    sub(b) {\r\n        if (typeof b == "object")\r\n            return new Vec(this.v[0] - b.v[0], this.v[1] - b.v[1]);\r\n        else\r\n            return new Vec(this.v[0] - b, this.v[1] - b);\r\n    }\r\n    ;\r\n    dot(b) {\r\n        if (typeof b == "object")\r\n            return (this.v[0] * b.v[0] + this.v[1] * b.v[1]);\r\n        else\r\n            return (this.v[0] * b + this.v[1] * b);\r\n    }\r\n    ;\r\n    fromArr(a) { return new Vec(a[0], a[1]); }\r\n    ;\r\n    len() { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    ;\r\n    normalize() { return this.div(this.len()); }\r\n    ;\r\n    rot(angle) {\r\n        var rmat = [\r\n            cos(angle), -sin(angle),\r\n            sin(angle), cos(angle)\r\n        ];\r\n        return new Vec(this.x * rmat[0] + this.y * rmat[2], this.x * rmat[1] + this.y * rmat[3]);\r\n    }\r\n}\r\nclass Vec3 {\r\n    constructor(a, b, c) {\r\n        if (a == NaN || b == undefined)\r\n            throw "num error";\r\n        this.v = [];\r\n        this.v[0] = a;\r\n        this.v[1] = b;\r\n        this.v[2] = c;\r\n    }\r\n    get x() { return this.v[0]; }\r\n    ;\r\n    get y() { return this.v[1]; }\r\n    ;\r\n    get z() { return this.v[2]; }\r\n    ;\r\n    setX(a) { this.v[0] = a; }\r\n    ;\r\n    setY(a) { this.v[1] = a; }\r\n    ;\r\n    setZ(a) { this.v[2] = a; }\r\n    ;\r\n    add(b) {\r\n        if (typeof b == "object")\r\n            return new Vec3(this.v[0] + b.v[0], this.v[1] + b.v[1], this.v[2] + b.v[2]);\r\n        else\r\n            return new Vec3(this.x + b, this.y + b, this.z + b);\r\n    }\r\n    ;\r\n    mul(b) {\r\n        if (typeof b == "object")\r\n            return new Vec3(this.v[0] * b.v[0], this.v[1] * b.v[1], this.v[2] * b.v[2]);\r\n        else\r\n            return new Vec3(this.x * b, this.y * b, this.z * b);\r\n    }\r\n    ;\r\n    div(b) {\r\n        if (typeof b == "object")\r\n            return new Vec3(this.v[0] / b.v[0], this.v[1] / b.v[1], this.v[2] / b.v[2]);\r\n        else\r\n            return new Vec3(this.x / b, this.y / b, this.z / b);\r\n    }\r\n    ;\r\n    sub(b) {\r\n        if (typeof b == "object")\r\n            return new Vec3(this.v[0] - b.v[0], this.v[1] - b.v[1], this.v[2] - b.v[2]);\r\n        else\r\n            return new Vec3(this.x - b, this.y - b, this.z - b);\r\n    }\r\n    ;\r\n    dot(b) {\r\n        if (typeof b == "object")\r\n            return (this.v[0] * b.v[0] + this.v[1] * b.v[1] + this.v[2] * b.v[2]);\r\n        else\r\n            return this.x * b + this.y * b + this.z * b;\r\n    }\r\n    ;\r\n    cross(b) {\r\n        var a = this;\r\n        return new Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\r\n    }\r\n    ;\r\n    len() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }\r\n    ;\r\n    normalize() { return this.div(this.len()); }\r\n    ;\r\n    fromArr(a) { return new Vec3(a[0], a[1], a[2]); }\r\n    ;\r\n    rot(angle, axis) {\r\n        let idxa = 0;\r\n        let idxb = 0;\r\n        if (axis == \'x\') {\r\n            idxa = 1;\r\n            idxb = 2;\r\n        }\r\n        else if (axis == \'y\') {\r\n            idxa = 0;\r\n            idxb = 2;\r\n        }\r\n        else if (axis == \'z\') {\r\n            idxa = 0;\r\n            idxb = 1;\r\n        }\r\n        const rotated = new Vec(this.v[idxa], this.v[idxb]).rot(angle);\r\n        let newVec = new Vec3(this.x, this.y, this.z);\r\n        newVec.v[idxa] = rotated.x;\r\n        newVec.v[idxb] = rotated.y;\r\n        return newVec;\r\n    }\r\n}\r\nclass Vec4 {\r\n    constructor(a, b, c, d) {\r\n        if (a == NaN || b == undefined)\r\n            throw "num error";\r\n        this.v = [];\r\n        this.v[0] = a;\r\n        this.v[1] = b;\r\n        this.v[2] = c;\r\n        this.v[3] = d;\r\n    }\r\n    x() { return this.v[0]; }\r\n    ;\r\n    y() { return this.v[1]; }\r\n    ;\r\n    z() { return this.v[2]; }\r\n    ;\r\n    w() { return this.v[3]; }\r\n    ;\r\n    setX(a) { this.v[0] = a; }\r\n    ;\r\n    setY(a) { this.v[1] = a; }\r\n    ;\r\n    setZ(a) { this.v[2] = a; }\r\n    ;\r\n    setW(a) { this.v[3] = a; }\r\n    ;\r\n    add(b) {\r\n        if (typeof b == "object")\r\n            return new Vec4(this.v[0] + b.v[0], this.v[1] + b.v[1], this.v[2] + b.v[2], this.v[3] + b.v[3]);\r\n        else\r\n            return new Vec4(this.x() + b, this.y() + b, this.z() + b, this.w() + b);\r\n    }\r\n    ;\r\n    mul(b) {\r\n        if (typeof b == "object")\r\n            return new Vec4(this.v[0] * b.v[0], this.v[1] * b.v[1], this.v[2] * b.v[2], this.v[3] * b.v[3]);\r\n        else\r\n            return new Vec4(this.x() * b, this.y() * b, this.z() * b, this.w() * b);\r\n    }\r\n    ;\r\n    div(b) {\r\n        if (typeof b == "object")\r\n            return new Vec4(this.v[0] / b.v[0], this.v[1] / b.v[1], this.v[2] / b.v[2], this.v[3] / b.v[3]);\r\n        else\r\n            return new Vec4(this.x() / b, this.y() / b, this.z() / b, this.w() / b);\r\n    }\r\n    ;\r\n    sub(b) {\r\n        if (typeof b == "object")\r\n            return new Vec4(this.v[0] - b.v[0], this.v[1] - b.v[1], this.v[2] - b.v[2], this.v[3] - b.v[3]);\r\n        else\r\n            return new Vec4(this.x() - b, this.y() - b, this.z() - b, this.w() - b);\r\n    }\r\n    ;\r\n    dot(b) {\r\n        if (typeof b == "object")\r\n            return (this.v[0] * b.v[0] + this.v[1] * b.v[1] + this.v[2] * b.v[2] + this.v[3] * b.v[3]);\r\n        else\r\n            return this.x() * b + this.y() * b + this.z() * b + this.w() * b;\r\n    }\r\n    ;\r\n    len() { return Math.sqrt(this.x() * this.x() + this.y() * this.y() + this.z() * this.z() + this.w() * this.w()); }\r\n    ;\r\n    normalize() { return this.div(this.len()); }\r\n    ;\r\n    fromArr(a) { return new Vec4(a[0], a[1], a[2], a[3]); }\r\n    ;\r\n}\r\nclass Shapes {\r\n    cross(pos, size) {\r\n        return [\r\n            [pos.x + size, pos.y + size],\r\n            [pos.x - size, pos.y - size],\r\n            [0, 0],\r\n            [pos.x + size, pos.y - size],\r\n            [pos.x - size, pos.y + size],\r\n        ];\r\n    }\r\n    ;\r\n}\r\n;\r\n\n;// CONCATENATED MODULE: ./src/utils/utils.ts\n\r\nfunction loop(n, cb) {\r\n    for (let i = 0; i < n; i++) {\r\n        cb(i, n);\r\n    }\r\n}\r\nfunction ifExistsAElseB(A, B) {\r\n    return A ? A : B;\r\n}\r\nclass Col {\r\n    constructor(color, idx) {\r\n        this.color = color;\r\n        this.idx = idx;\r\n    }\r\n}\r\nclass Palette {\r\n    constructor() {\r\n        this.cols = [];\r\n        this.blendMode = "lrgb";\r\n        this.smoothInterpolation = true;\r\n    }\r\n    addCols(cols) {\r\n        for (let col of cols) {\r\n            this.addCol(col.color, col.idx);\r\n        }\r\n    }\r\n    addCol(col, idx = this.cols.length === 0\r\n        ? 0\r\n        : this.cols[this.cols.length - 1].idx + (1 - this.cols[this.cols.length - 1].idx) * 0.5) {\r\n        this.cols.push({\r\n            color: col,\r\n            idx: idx,\r\n        });\r\n    }\r\n    pickCol(idx) {\r\n        for (let i = 0; i < this.cols.length; i++) {\r\n            const colCurr = this.cols[i];\r\n            const colNext = this.cols[(i + 1) % this.cols.length];\r\n            if (colCurr.idx <= idx) {\r\n                let dist;\r\n                let fr;\r\n                if (i === this.cols.length - 1) {\r\n                    dist = 1. - colCurr.idx + colNext.idx;\r\n                    fr = (idx - colCurr.idx) / dist;\r\n                }\r\n                else {\r\n                    if (idx < colNext.idx) {\r\n                        dist = colNext.idx - colCurr.idx;\r\n                        fr = (idx - colCurr.idx) / dist;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (this.smoothInterpolation)\r\n                    fr = smoothstep(0, 1, fr);\r\n                let col = [\r\n                    colCurr.color[0] * fr + colNext.color[0] * (1 - fr),\r\n                    colCurr.color[1] * fr + colNext.color[1] * (1 - fr),\r\n                    colCurr.color[2] * fr + colNext.color[2] * (1 - fr),\r\n                    1\r\n                ];\r\n                return col;\r\n            }\r\n        }\r\n        return [...this.cols[this.cols.length - 1].color];\r\n    }\r\n    getTexArr(res) {\r\n        const palArr = new Float32Array(res * 4);\r\n        loop(res, (i) => {\r\n            const mul = 1;\r\n            const c = this.pickCol(i / res);\r\n            const idx = i * 4;\r\n            palArr[idx + 0] = (c[0] * mul);\r\n            palArr[idx + 1] = (c[1] * mul);\r\n            palArr[idx + 2] = (c[2] * mul);\r\n            palArr[idx + 3] = mul;\r\n        });\r\n        return palArr;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@0b5vr/experimental/dist/0b5vr-experimental.esm.js\n/*!\n* @0b5vr/experimental v0.8.0\n* Experimental edition of 0b5vr\n*\n* Copyright (c) 2019-2022 0b5vr\n* @0b5vr/experimental is distributed under MIT License\n* https://github.com/0b5vr/experimental-npm/blob/release/LICENSE\n*/\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/algorithm/binarySearch.ts\nfunction binarySearch(array, elementOrCompare) {\n  if (typeof elementOrCompare !== "function") {\n    return binarySearch(array, (element) => element < elementOrCompare);\n  }\n  const compare = elementOrCompare;\n  let start = 0;\n  let end = array.length;\n  while (start < end) {\n    const center = start + end >> 1;\n    const centerElement = array[center];\n    const compareResult = compare(centerElement);\n    if (compareResult) {\n      start = center + 1;\n    } else {\n      end = center;\n    }\n  }\n  return start;\n}\n\n// src/array/arraySet.ts\nfunction arraySetDelete(array, value) {\n  const index = array.indexOf(value);\n  if (index === -1) {\n    return false;\n  }\n  array.splice(index, 1);\n  return true;\n}\nfunction arraySetHas(array, value) {\n  return array.indexOf(value) !== -1;\n}\nfunction arraySetAdd(array, value) {\n  const index = array.indexOf(value);\n  if (index !== -1) {\n    return false;\n  }\n  array.push(value);\n  return true;\n}\nfunction arraySetUnion(a, b) {\n  const out = [...a];\n  b.forEach((v) => {\n    if (!arraySetHas(out, v)) {\n      out.push(v);\n    }\n  });\n  return out;\n}\nfunction arraySetDiff(from, diff) {\n  const out = [...from];\n  diff.forEach((v) => {\n    arraySetDelete(out, v);\n  });\n  return out;\n}\n\n// src/array/constants.ts\nvar TRIANGLE_STRIP_QUAD = (/* unused pure expression or super */ null && ([-1, -1, 1, -1, -1, 1, 1, 1]));\nvar TRIANGLE_STRIP_QUAD_3D = (/* unused pure expression or super */ null && ([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]));\nvar TRIANGLE_STRIP_QUAD_NORMAL = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]));\nvar TRIANGLE_STRIP_QUAD_UV = (/* unused pure expression or super */ null && ([0, 0, 1, 0, 0, 1, 1, 1]));\n\n// src/array/utils.ts\nfunction shuffleArray(array, dice) {\n  const f = dice ? dice : () => Math.random();\n  for (let i = 0; i < array.length - 1; i++) {\n    const ir = i + Math.floor(f() * (array.length - i));\n    const temp = array[ir];\n    array[ir] = array[i];\n    array[i] = temp;\n  }\n  return array;\n}\nfunction triIndexToLineIndex(array) {\n  const ret = [];\n  for (let i = 0; i < array.length / 3; i++) {\n    const head = i * 3;\n    ret.push(array[head], array[head + 1], array[head + 1], array[head + 2], array[head + 2], array[head]);\n  }\n  return ret;\n}\nfunction matrix2d(w, h) {\n  const arr = [];\n  for (let iy = 0; iy < h; iy++) {\n    for (let ix = 0; ix < w; ix++) {\n      arr.push(ix, iy);\n    }\n  }\n  return arr;\n}\nfunction matrix3d(w, h, d) {\n  const arr = [];\n  for (let iz = 0; iz < d; iz++) {\n    for (let iy = 0; iy < h; iy++) {\n      for (let ix = 0; ix < w; ix++) {\n        arr.push(ix, iy, iz);\n      }\n    }\n  }\n  return arr;\n}\n\n// src/CDS/CDS.ts\nvar CDS = class {\n  constructor() {\n    this.factor = 100;\n    this.ratio = 1;\n    this.velocity = 0;\n    this.value = 0;\n    this.target = 0;\n  }\n  update(deltaTime) {\n    this.velocity += (-this.factor * (this.value - this.target) - 2 * this.velocity * Math.sqrt(this.factor) * this.ratio) * deltaTime;\n    this.value += this.velocity * deltaTime;\n    return this.value;\n  }\n};\n\n// src/Clock/Clock.ts\nvar Clock = class {\n  constructor() {\n    this.__time = 0;\n    this.__deltaTime = 0;\n    this.__isPlaying = false;\n  }\n  get time() {\n    return this.__time;\n  }\n  get deltaTime() {\n    return this.__deltaTime;\n  }\n  get isPlaying() {\n    return this.__isPlaying;\n  }\n  update(time) {\n    const prevTime = this.__time;\n    this.__time = time || 0;\n    this.__deltaTime = this.__time - prevTime;\n  }\n  play() {\n    this.__isPlaying = true;\n  }\n  pause() {\n    this.__isPlaying = false;\n  }\n  setTime(time) {\n    this.__time = time;\n  }\n};\n\n// src/Clock/ClockFrame.ts\nvar ClockFrame = class extends (/* unused pure expression or super */ null && (Clock)) {\n  constructor(fps = 60) {\n    super();\n    this.__frame = 0;\n    this.__fps = fps;\n  }\n  get frame() {\n    return this.__frame;\n  }\n  get fps() {\n    return this.__fps;\n  }\n  update() {\n    if (this.__isPlaying) {\n      this.__time = this.__frame / this.__fps;\n      this.__deltaTime = 1 / this.__fps;\n      this.__frame++;\n    } else {\n      this.__deltaTime = 0;\n    }\n  }\n  setTime(time) {\n    this.__frame = Math.floor(this.__fps * time);\n    this.__time = this.__frame / this.__fps;\n  }\n};\n\n// src/Clock/ClockRealtime.ts\nvar ClockRealtime = class extends (/* unused pure expression or super */ null && (Clock)) {\n  constructor() {\n    super(...arguments);\n    this.__rtTime = 0;\n    this.__rtDate = performance.now();\n  }\n  get isRealtime() {\n    return true;\n  }\n  update() {\n    const now = performance.now();\n    if (this.__isPlaying) {\n      const prevTime = this.__time;\n      const deltaDate = now - this.__rtDate;\n      this.__time = this.__rtTime + deltaDate / 1e3;\n      this.__deltaTime = this.time - prevTime;\n    } else {\n      this.__rtTime = this.time;\n      this.__rtDate = now;\n      this.__deltaTime = 0;\n    }\n  }\n  setTime(time) {\n    this.__time = time;\n    this.__rtTime = this.time;\n    this.__rtDate = performance.now();\n  }\n};\n\n// src/math/utils.ts\nfunction _0b5vr_experimental_esm_lerp(a, b, x) {\n  return a + (b - a) * x;\n}\nfunction _0b5vr_experimental_esm_clamp(x, l, h) {\n  return Math.min(Math.max(x, l), h);\n}\nfunction _0b5vr_experimental_esm_saturate(x) {\n  return _0b5vr_experimental_esm_clamp(x, 0, 1);\n}\nfunction range(x, x0, x1, y0, y1) {\n  return (x - x0) * (y1 - y0) / (x1 - x0) + y0;\n}\nfunction _0b5vr_experimental_esm_linearstep(a, b, x) {\n  return _0b5vr_experimental_esm_saturate((x - a) / (b - a));\n}\nfunction _0b5vr_experimental_esm_smoothstep(a, b, x) {\n  const t = _0b5vr_experimental_esm_linearstep(a, b, x);\n  return t * t * (3 - 2 * t);\n}\nfunction smootherstep(a, b, x) {\n  const t = _0b5vr_experimental_esm_linearstep(a, b, x);\n  return t * t * t * (t * (t * 6 - 15) + 10);\n}\nfunction smootheststep(a, b, x) {\n  const t = _0b5vr_experimental_esm_linearstep(a, b, x);\n  return t * t * t * t * (t * (t * (-20 * t + 70) - 84) + 35);\n}\n\n// src/color/colorToHex.ts\nfunction colorToHex(color) {\n  return "#" + color.map((v) => ("0" + Math.round(_0b5vr_experimental_esm_saturate(v) * 255).toString(16)).slice(-2)).join("");\n}\n\n// src/color/eotfRec709.ts\nfunction eotfRec709(value) {\n  return value.map((v) => v < 0.081 ? v / 4.5 : Math.pow((v + 0.099) / 1.099, 1 / 0.45));\n}\n\n// src/color/oetfRec709.ts\nfunction oetfRec709(luminance) {\n  return luminance.map((l) => l < 0.018 ? 4.5 * l : 1.099 * Math.pow(l, 0.45) - 0.099);\n}\n\n// src/edt/edt.ts\nfunction edt1d(data, offset, stride, length) {\n  let k = 0;\n  const v = new Float32Array(length);\n  v[0] = 0;\n  const z = new Float32Array(length + 1);\n  z[0] = -Infinity;\n  z[1] = Infinity;\n  const f = new Float32Array(length);\n  for (let q = 0; q < length; q++) {\n    f[q] = data[offset + q * stride];\n  }\n  for (let q = 1; q < length; q++) {\n    let s = 0;\n    while (0 <= k) {\n      s = (f[q] + q * q - f[v[k]] - v[k] * v[k]) / (2 * q - 2 * v[k]);\n      if (s <= z[k]) {\n        k--;\n      } else {\n        break;\n      }\n    }\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = Infinity;\n  }\n  k = 0;\n  for (let q = 0; q < length; q++) {\n    while (z[k + 1] < q) {\n      k++;\n    }\n    const qSubVK = q - v[k];\n    data[offset + q * stride] = f[v[k]] + qSubVK * qSubVK;\n  }\n}\nfunction edt2d(data, width, height) {\n  for (let x = 0; x < width; x++) {\n    edt1d(data, x, width, height);\n  }\n  for (let y = 0; y < height; y++) {\n    edt1d(data, y * width, 1, width);\n  }\n}\n\n// src/ExpSmooth/ExpSmooth.ts\nvar ExpSmooth = class {\n  constructor() {\n    this.factor = 10;\n    this.target = 0;\n    this.value = 0;\n  }\n  update(deltaTime) {\n    this.value = _0b5vr_experimental_esm_lerp(this.target, this.value, Math.exp(-this.factor * deltaTime));\n    return this.value;\n  }\n};\n\n// src/Pool/Pool.ts\nvar Pool = class {\n  constructor(array) {\n    this.index = 0;\n    this.array = array;\n  }\n  get current() {\n    return this.array[this.index];\n  }\n  next() {\n    this.index = (this.index + 1) % this.array.length;\n    return this.current;\n  }\n};\n\n// src/GPUTimer/GPUTimer.ts\nvar GPUTimer = class {\n  static isSupported(gl) {\n    return new Set(gl.getSupportedExtensions()).has("EXT_disjoint_timer_query_webgl2");\n  }\n  constructor(gl) {\n    this.gl = gl;\n    const queries = new Array(1024).fill(1).map(() => gl.createQuery());\n    this.queries = new Pool(queries);\n    this.stack = [];\n    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2");\n    this.__loopTasks = /* @__PURE__ */ new Set();\n    const update = () => {\n      this.update();\n      requestAnimationFrame(update);\n    };\n    update();\n  }\n  update() {\n    Array.from(this.__loopTasks).forEach((task) => task());\n  }\n  measure(func) {\n    return __async(this, null, function* () {\n      const { gl } = this;\n      if (this.stack.length !== 0) {\n        gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n        const promiseFinishingPrev = this.check(this.queries.current);\n        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {\n          return (yield promiseAccum2) + (yield promiseFinishingPrev);\n        }));\n      }\n      this.stack.push(Promise.resolve(0));\n      gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());\n      func();\n      gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      const promiseAccum = this.stack.pop();\n      const promiseThis = this.check(this.queries.current);\n      if (this.stack.length !== 0) {\n        this.stack = this.stack.map((promiseAccum2) => __async(this, null, function* () {\n          return (yield promiseAccum2) + (yield promiseThis);\n        }));\n        gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.queries.next());\n      }\n      return (yield promiseAccum) + (yield promiseThis);\n    });\n  }\n  check(query) {\n    const { gl } = this;\n    return new Promise((resolve) => {\n      const task = () => {\n        const isAvailable = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);\n        if (isAvailable) {\n          this.__loopTasks.delete(task);\n          resolve(gl.getQueryParameter(query, gl.QUERY_RESULT) * 1e-3 * 1e-3);\n        }\n      };\n      this.__loopTasks.add(task);\n    });\n  }\n};\n\n// src/HistoryMeanCalculator/HistoryMeanCalculator.ts\nvar HistoryMeanCalculator = class {\n  constructor(length) {\n    this.__recalcForEach = 0;\n    this.__countUntilRecalc = 0;\n    this.__history = [];\n    this.__index = 0;\n    this.__count = 0;\n    this.__cache = 0;\n    this.__length = length;\n    this.__recalcForEach = length;\n    for (let i = 0; i < length; i++) {\n      this.__history[i] = 0;\n    }\n  }\n  get mean() {\n    const count = Math.min(this.__count, this.__length);\n    return count === 0 ? 0 : this.__cache / count;\n  }\n  get recalcForEach() {\n    return this.__recalcForEach;\n  }\n  set recalcForEach(value) {\n    const delta = value - this.__recalcForEach;\n    this.__recalcForEach = value;\n    this.__countUntilRecalc = Math.max(0, this.__countUntilRecalc + delta);\n  }\n  reset() {\n    this.__index = 0;\n    this.__count = 0;\n    this.__cache = 0;\n    this.__countUntilRecalc = 0;\n    for (let i = 0; i < this.__length; i++) {\n      this.__history[i] = 0;\n    }\n  }\n  push(value) {\n    const prev = this.__history[this.__index];\n    this.__history[this.__index] = value;\n    this.__count++;\n    this.__index = (this.__index + 1) % this.__length;\n    if (this.__countUntilRecalc === 0) {\n      this.recalc();\n    } else {\n      this.__countUntilRecalc--;\n      this.__cache -= prev;\n      this.__cache += value;\n    }\n  }\n  recalc() {\n    this.__countUntilRecalc = this.__recalcForEach;\n    const sum = this.__history.slice(0, Math.min(this.__count, this.__length)).reduce((sum2, v) => sum2 + v, 0);\n    this.__cache = sum;\n  }\n};\n\n// src/HistoryMeanCalculator/HistoryPercentileCalculator.ts\nvar HistoryPercentileCalculator = class {\n  constructor(length) {\n    this.__history = [];\n    this.__sorted = [];\n    this.__index = 0;\n    this.__length = length;\n  }\n  get median() {\n    return this.percentile(50);\n  }\n  percentile(percentile) {\n    if (this.__history.length === 0) {\n      return 0;\n    }\n    return this.__sorted[Math.round(percentile * 0.01 * (this.__history.length - 1))];\n  }\n  reset() {\n    this.__index = 0;\n    this.__history = [];\n    this.__sorted = [];\n  }\n  push(value) {\n    const prev = this.__history[this.__index];\n    this.__history[this.__index] = value;\n    this.__index = (this.__index + 1) % this.__length;\n    if (this.__sorted.length === this.__length) {\n      const prevIndex = binarySearch(this.__sorted, prev);\n      this.__sorted.splice(prevIndex, 1);\n    }\n    const index = binarySearch(this.__sorted, value);\n    this.__sorted.splice(index, 0, value);\n  }\n};\n\n// src/HistoryMeanCalculator/HistoryMedianCalculator.ts\nvar HistoryMedianCalculator = class extends (/* unused pure expression or super */ null && (HistoryPercentileCalculator)) {\n  constructor(length) {\n    super(length);\n    console.warn("HistoryMedianCalculator: Deprecated. Use HistoryPercentileCalculator instead");\n  }\n};\n\n// src/MapOfSet/MapOfSet.ts\nvar MapOfSet = class {\n  constructor() {\n    this.map = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    var _a;\n    return (_a = this.map.get(key)) != null ? _a : /* @__PURE__ */ new Set();\n  }\n  add(key, value) {\n    let set = this.map.get(key);\n    if (set == null) {\n      set = /* @__PURE__ */ new Set();\n      this.map.set(key, set);\n    }\n    set.add(value);\n  }\n};\n\n// src/math/mat3/mat3Determinant.ts\nfunction mat3Determinant(m) {\n  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13;\n  return n11 * t11 + n21 * t12 + n31 * t13;\n}\n\n// src/math/mat3/mat3FromMat4.ts\nfunction mat3FromMat4(source) {\n  return [\n    source[0],\n    source[1],\n    source[2],\n    source[4],\n    source[5],\n    source[6],\n    source[8],\n    source[9],\n    source[10]\n  ];\n}\n\n// src/math/mat3/mat3FromQuaternion.ts\nfunction mat3FromQuaternion(quat) {\n  const x = quat[0];\n  const y = quat[1];\n  const z = quat[2];\n  const w = quat[3];\n  return [\n    1 - 2 * y * y - 2 * z * z,\n    2 * x * y + 2 * z * w,\n    2 * x * z - 2 * y * w,\n    2 * x * y - 2 * z * w,\n    1 - 2 * x * x - 2 * z * z,\n    2 * y * z + 2 * x * w,\n    2 * x * z + 2 * y * w,\n    2 * y * z - 2 * x * w,\n    1 - 2 * x * x - 2 * y * y\n  ];\n}\n\n// src/math/vec/vecScale.ts\nfunction vecScale(vec, scalar) {\n  return vec.map((v) => v * scalar);\n}\n\n// src/math/mat3/mat3Inverse.ts\nfunction mat3Inverse(m) {\n  const n11 = m[0], n21 = m[1], n31 = m[2], n12 = m[3], n22 = m[4], n32 = m[5], n13 = m[6], n23 = m[7], n33 = m[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n  if (det === 0) {\n    return vecScale(m, 0);\n  }\n  return vecScale([\n    t11,\n    n31 * n23 - n33 * n21,\n    n32 * n21 - n31 * n22,\n    t12,\n    n33 * n11 - n31 * n13,\n    n31 * n12 - n32 * n11,\n    t13,\n    n21 * n13 - n23 * n11,\n    n22 * n11 - n21 * n12\n  ], 1 / det);\n}\n\n// src/math/mat3/mat3Multiply.ts\nfunction mat3Multiply(...mats) {\n  if (mats.length < 2) {\n    return mats[0];\n  }\n  const a = mats.shift();\n  const b = mat3Multiply(...mats);\n  const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02,\n    a01 * b00 + a11 * b01 + a21 * b02,\n    a02 * b00 + a12 * b01 + a22 * b02,\n    a00 * b10 + a10 * b11 + a20 * b12,\n    a01 * b10 + a11 * b11 + a21 * b12,\n    a02 * b10 + a12 * b11 + a22 * b12,\n    a00 * b20 + a10 * b21 + a20 * b22,\n    a01 * b20 + a11 * b21 + a21 * b22,\n    a02 * b20 + a12 * b21 + a22 * b22\n  ];\n}\n\n// src/math/mat3/mat3Transpose.ts\nfunction mat3Transpose(source) {\n  return [\n    source[0],\n    source[3],\n    source[6],\n    source[1],\n    source[4],\n    source[7],\n    source[2],\n    source[5],\n    source[8]\n  ];\n}\n\n// src/math/mat3/Matrix3.ts\nvar rawIdentityMatrix3 = [\n  1,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  1\n];\nvar Matrix3 = class {\n  constructor(v = rawIdentityMatrix3) {\n    this.elements = v;\n  }\n  get transpose() {\n    return new Matrix3(mat3Transpose(this.elements));\n  }\n  get determinant() {\n    return mat3Determinant(this.elements);\n  }\n  get inverse() {\n    return new Matrix3(mat3Inverse(this.elements));\n  }\n  get matrix4() {\n    return Matrix4.fromMatrix3(this);\n  }\n  toString() {\n    const m = this.elements.map((v) => v.toFixed(3));\n    return `Matrix3( ${m[0]}, ${m[3]}, ${m[6]}; ${m[1]}, ${m[4]}, ${m[7]}; ${m[2]}, ${m[5]}, ${m[8]} )`;\n  }\n  clone() {\n    return new Matrix3(this.elements.concat());\n  }\n  multiply(...matrices) {\n    return Matrix3.multiply(this, ...matrices);\n  }\n  scaleScalar(scalar) {\n    return new Matrix3(vecScale(this.elements, scalar));\n  }\n  static get identity() {\n    return new Matrix3(rawIdentityMatrix3);\n  }\n  static multiply(...matrices) {\n    if (matrices.length === 0) {\n      return Matrix3.identity;\n    } else {\n      return new Matrix3(mat3Multiply(...matrices.map((m) => m.elements)));\n    }\n  }\n  static fromMatrix4(matrix4) {\n    return new Matrix3(mat3FromMat4(matrix4.elements));\n  }\n  static fromQuaternion(quaternion) {\n    return new Matrix3(mat3FromQuaternion(quaternion.elements));\n  }\n};\n\n// src/math/vec/vecAdd.ts\nfunction vecAdd(...vecs) {\n  if (vecs.length < 2) {\n    return vecs[0];\n  }\n  const a = vecs.shift();\n  const b = vecAdd(...vecs);\n  return a.map((v, i) => v + b[i]);\n}\n\n// src/math/vec/vecDivide.ts\nfunction vecDivide(vecA, vecB) {\n  return vecA.map((v, i) => v / vecB[i]);\n}\n\n// src/math/vec/vecDot.ts\nfunction vecDot(vecA, vecB) {\n  return vecA.reduce((sum, v, i) => sum + v * vecB[i], 0);\n}\n\n// src/math/vec/vecLength.ts\nfunction vecLength(vec) {\n  return Math.sqrt(vec.reduce((sum, v) => sum + v * v, 0));\n}\n\n// src/math/vec/vecLengthSq.ts\nfunction vecLengthSq(vec) {\n  return vec.reduce((sum, v) => sum + v * v, 0);\n}\n\n// src/math/vec/vecManhattanLength.ts\nfunction vecManhattanLength(vec) {\n  return vec.reduce((sum, v) => sum + Math.abs(v), 0);\n}\n\n// src/math/vec/vecMultiply.ts\nfunction vecMultiply(...vecs) {\n  if (vecs.length < 2) {\n    return vecs[0];\n  }\n  const a = vecs.shift();\n  const b = vecMultiply(...vecs);\n  return a.map((v, i) => v * b[i]);\n}\n\n// src/math/vec/vecNeg.ts\nfunction vecNeg(vec) {\n  return vec.map((v) => -v);\n}\n\n// src/math/vec/vecNormalize.ts\nfunction vecNormalize(vec) {\n  const len = vecLength(vec);\n  const invLen = len === 0 ? 0 : 1 / len;\n  return vecScale(vec, invLen);\n}\n\n// src/math/vec/vecSub.ts\nfunction vecSub(vecA, vecB) {\n  return vecA.map((v, i) => v - vecB[i]);\n}\n\n// src/math/vec/Vector.ts\nvar Vector = class {\n  get length() {\n    return vecLength(this.elements);\n  }\n  get lengthSq() {\n    return vecLengthSq(this.elements);\n  }\n  get manhattanLength() {\n    return vecManhattanLength(this.elements);\n  }\n  get normalized() {\n    return this.__new(vecNormalize(this.elements));\n  }\n  get negated() {\n    return this.__new(vecNeg(this.elements));\n  }\n  clone() {\n    return this.__new(this.elements.concat());\n  }\n  add(...vectors) {\n    return this.__new(vecAdd(this.elements, ...vectors.map((v) => v.elements)));\n  }\n  sub(vector) {\n    return this.__new(vecSub(this.elements, vector.elements));\n  }\n  multiply(...vectors) {\n    return this.__new(vecMultiply(this.elements, ...vectors.map((v) => v.elements)));\n  }\n  divide(vector) {\n    return this.__new(vecDivide(this.elements, vector.elements));\n  }\n  scale(scalar) {\n    return this.__new(vecScale(this.elements, scalar));\n  }\n  dot(vector) {\n    return vecDot(this.elements, vector.elements);\n  }\n};\n\n// src/math/vec4/vec4ApplyMatrix4.ts\nfunction vec4ApplyMatrix4(v, m) {\n  return [\n    m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],\n    m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],\n    m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],\n    m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3]\n  ];\n}\n\n// src/math/vec3/vec3ApplyMatrix4.ts\nfunction vec3ApplyMatrix4(v, m) {\n  const vec4 = vec4ApplyMatrix4([...v, 1], m);\n  const xyz = [vec4[0], vec4[1], vec4[2]];\n  const w = vec4[3];\n  return vecScale(xyz, 1 / w);\n}\n\n// src/math/quat/quatInverse.ts\nfunction quatInverse(quat) {\n  return [-quat[0], -quat[1], -quat[2], quat[3]];\n}\n\n// src/math/quat/quatMultiply.ts\nfunction quatMultiply(...quats) {\n  if (quats.length < 2) {\n    return quats[0];\n  }\n  const a = quats.shift();\n  const b = quatMultiply(...quats);\n  return [\n    a[3] * b[0] + a[0] * b[3] + a[1] * b[2] - a[2] * b[1],\n    a[3] * b[1] - a[0] * b[2] + a[1] * b[3] + a[2] * b[0],\n    a[3] * b[2] + a[0] * b[1] - a[1] * b[0] + a[2] * b[3],\n    a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]\n  ];\n}\n\n// src/math/vec3/vec3ApplyQuaternion.ts\nfunction vec3ApplyQuaternion(vec, quat) {\n  const p = [...vec, 0];\n  const r = quatInverse(quat);\n  const res = quatMultiply(quat, p, r);\n  res.pop();\n  return res;\n}\n\n// src/math/vec3/vec3Cross.ts\nfunction vec3Cross(vecA, vecB) {\n  return [\n    vecA[1] * vecB[2] - vecA[2] * vecB[1],\n    vecA[2] * vecB[0] - vecA[0] * vecB[2],\n    vecA[0] * vecB[1] - vecA[1] * vecB[0]\n  ];\n}\n\n// src/math/vec3/vec3OrthoNormalize.ts\nfunction vec3OrthoNormalize(normal, tangent = [0, 1, 0], binormal) {\n  const n = vecNormalize(normal);\n  let t = vecNormalize(tangent);\n  let dotNT = vecDot(n, t);\n  if (dotNT === 1) {\n    if (Math.abs(n[1]) > Math.abs(n[2])) {\n      t = [0, 0, 1];\n    } else {\n      t = [0, 1, 0];\n    }\n    dotNT = vecDot(n, t);\n  }\n  t = vecNormalize(vecSub(t, vecScale(n, dotNT)));\n  let b = vec3Cross(t, n);\n  if (binormal && vecDot(b, binormal) < 0) {\n    b = vecNeg(b);\n  }\n  return {\n    normal: n,\n    tangent: t,\n    binormal: b\n  };\n}\n\n// src/math/vec3/Vector3.ts\nvar Vector3 = class extends Vector {\n  constructor(v = [0, 0, 0]) {\n    super();\n    this.elements = v;\n  }\n  get x() {\n    return this.elements[0];\n  }\n  set x(x) {\n    this.elements[0] = x;\n  }\n  get y() {\n    return this.elements[1];\n  }\n  set y(y) {\n    this.elements[1] = y;\n  }\n  get z() {\n    return this.elements[2];\n  }\n  set z(z) {\n    this.elements[2] = z;\n  }\n  toString() {\n    return `Vector3( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} )`;\n  }\n  cross(vector) {\n    return new Vector3(vec3Cross(this.elements, vector.elements));\n  }\n  applyQuaternion(quaternion) {\n    return new Vector3(vec3ApplyQuaternion(this.elements, quaternion.elements));\n  }\n  applyMatrix4(matrix) {\n    return new Vector3(vec3ApplyMatrix4(this.elements, matrix.elements));\n  }\n  __new(v) {\n    return new Vector3(v);\n  }\n  static get zero() {\n    return new Vector3([0, 0, 0]);\n  }\n  static get one() {\n    return new Vector3([1, 1, 1]);\n  }\n  static orthoNormalize(normal, tangent, binormal) {\n    const result = vec3OrthoNormalize(normal.elements, tangent.elements, binormal.elements);\n    return {\n      normal: new Vector3(result.normal),\n      tangent: new Vector3(result.tangent),\n      binormal: new Vector3(result.binormal)\n    };\n  }\n};\n\n// src/math/mat4/mat4FromQuaternion.ts\nfunction mat4FromQuaternion(quat) {\n  const x = quat[0];\n  const y = quat[1];\n  const z = quat[2];\n  const w = quat[3];\n  return [\n    1 - 2 * y * y - 2 * z * z,\n    2 * x * y + 2 * z * w,\n    2 * x * z - 2 * y * w,\n    0,\n    2 * x * y - 2 * z * w,\n    1 - 2 * x * x - 2 * z * z,\n    2 * y * z + 2 * x * w,\n    0,\n    2 * x * z + 2 * y * w,\n    2 * y * z - 2 * x * w,\n    1 - 2 * x * x - 2 * y * y,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4Compose.ts\nfunction mat4Compose(position, rotation, scale) {\n  const matRot = mat4FromQuaternion(rotation);\n  const sx = scale[0], sy = scale[1], sz = scale[2];\n  return [\n    matRot[0] * sx,\n    matRot[1] * sx,\n    matRot[2] * sx,\n    0,\n    matRot[4] * sy,\n    matRot[5] * sy,\n    matRot[6] * sy,\n    0,\n    matRot[8] * sz,\n    matRot[9] * sz,\n    matRot[10] * sz,\n    0,\n    position[0],\n    position[1],\n    position[2],\n    1\n  ];\n}\n\n// src/math/mat4/mat4Determinant.ts\nfunction mat4Determinant(m) {\n  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n// src/math/quat/quatFromMatrix3.ts\nfunction quatFromMatrix3(m) {\n  const m11 = m[0], m12 = m[3], m13 = m[6], m21 = m[1], m22 = m[4], m23 = m[7], m31 = m[2], m32 = m[5], m33 = m[8], trace = m11 + m22 + m33;\n  if (trace > 0) {\n    const s = 0.5 / Math.sqrt(trace + 1);\n    return [\n      (m32 - m23) * s,\n      (m13 - m31) * s,\n      (m21 - m12) * s,\n      0.25 / s\n    ];\n  } else if (m11 > m22 && m11 > m33) {\n    const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n    return [\n      0.25 * s,\n      (m12 + m21) / s,\n      (m13 + m31) / s,\n      (m32 - m23) / s\n    ];\n  } else if (m22 > m33) {\n    const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n    return [\n      (m12 + m21) / s,\n      0.25 * s,\n      (m23 + m32) / s,\n      (m13 - m31) / s\n    ];\n  } else {\n    const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n    return [\n      (m13 + m31) / s,\n      (m23 + m32) / s,\n      0.25 * s,\n      (m21 - m12) / s\n    ];\n  }\n}\n\n// src/math/quat/quatFromMatrix4.ts\nfunction quatFromMatrix4(m) {\n  return quatFromMatrix3(mat3FromMat4(m));\n}\n\n// src/math/mat4/mat4Decompose.ts\nfunction mat4Decompose(m) {\n  let sx = vecLength([m[0], m[1], m[2]]);\n  const sy = vecLength([m[4], m[5], m[6]]);\n  const sz = vecLength([m[8], m[9], m[10]]);\n  const det = mat4Determinant(m);\n  if (det < 0) {\n    sx = -sx;\n  }\n  const invSx = 1 / sx;\n  const invSy = 1 / sy;\n  const invSz = 1 / sz;\n  const rotationMatrix = m.concat();\n  rotationMatrix[0] *= invSx;\n  rotationMatrix[1] *= invSx;\n  rotationMatrix[2] *= invSx;\n  rotationMatrix[4] *= invSy;\n  rotationMatrix[5] *= invSy;\n  rotationMatrix[6] *= invSy;\n  rotationMatrix[8] *= invSz;\n  rotationMatrix[9] *= invSz;\n  rotationMatrix[10] *= invSz;\n  return {\n    position: [m[12], m[13], m[14]],\n    scale: [sx, sy, sz],\n    rotation: quatFromMatrix4(rotationMatrix)\n  };\n}\n\n// src/math/mat4/mat4FromMat3.ts\nfunction mat4FromMat3(source) {\n  return [\n    source[0],\n    source[1],\n    source[2],\n    0,\n    source[3],\n    source[4],\n    source[5],\n    0,\n    source[6],\n    source[7],\n    source[8],\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4Inverse.ts\nfunction mat4Inverse(m) {\n  const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3], a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7], a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11], a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;\n  const det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  if (det === 0) {\n    return vecScale(m, 0);\n  }\n  return vecScale([\n    a11 * b11 - a12 * b10 + a13 * b09,\n    a02 * b10 - a01 * b11 - a03 * b09,\n    a31 * b05 - a32 * b04 + a33 * b03,\n    a22 * b04 - a21 * b05 - a23 * b03,\n    a12 * b08 - a10 * b11 - a13 * b07,\n    a00 * b11 - a02 * b08 + a03 * b07,\n    a32 * b02 - a30 * b05 - a33 * b01,\n    a20 * b05 - a22 * b02 + a23 * b01,\n    a10 * b10 - a11 * b08 + a13 * b06,\n    a01 * b08 - a00 * b10 - a03 * b06,\n    a30 * b04 - a31 * b02 + a33 * b00,\n    a21 * b02 - a20 * b04 - a23 * b00,\n    a11 * b07 - a10 * b09 - a12 * b06,\n    a00 * b09 - a01 * b07 + a02 * b06,\n    a31 * b01 - a30 * b03 - a32 * b00,\n    a20 * b03 - a21 * b01 + a22 * b00\n  ], 1 / det);\n}\n\n// src/math/mat4/mat4LookAt.ts\nfunction mat4LookAt(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {\n  const dir = vecNormalize(vecSub(position, target));\n  let sid = vecNormalize(vec3Cross(up, dir));\n  if (roll !== 0) {\n    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));\n  }\n  const top = vec3Cross(dir, sid);\n  return [\n    sid[0],\n    sid[1],\n    sid[2],\n    0,\n    top[0],\n    top[1],\n    top[2],\n    0,\n    dir[0],\n    dir[1],\n    dir[2],\n    0,\n    position[0],\n    position[1],\n    position[2],\n    1\n  ];\n}\n\n// src/math/mat4/mat4LookAtInverse.ts\nfunction mat4LookAtInverse(position, target = [0, 0, 0], up = [0, 1, 0], roll = 0) {\n  const dir = vecNormalize(vecSub(position, target));\n  let sid = vecNormalize(vec3Cross(up, dir));\n  if (roll !== 0) {\n    sid = vecAdd(vecScale(sid, Math.cos(roll)), vecScale(vec3Cross(dir, sid), Math.sin(roll)));\n  }\n  const top = vec3Cross(dir, sid);\n  return [\n    sid[0],\n    top[0],\n    dir[0],\n    0,\n    sid[1],\n    top[1],\n    dir[1],\n    0,\n    sid[2],\n    top[2],\n    dir[2],\n    0,\n    -vecDot(sid, position),\n    -vecDot(top, position),\n    -vecDot(dir, position),\n    1\n  ];\n}\n\n// src/math/mat4/mat4Multiply.ts\nfunction mat4Multiply(...mats) {\n  if (mats.length < 2) {\n    return mats[0];\n  }\n  const a = mats.shift();\n  const b = mat4Multiply(...mats);\n  const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3], b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7], b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11], b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];\n  return [\n    a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03,\n    a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03,\n    a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03,\n    a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03,\n    a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13,\n    a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13,\n    a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13,\n    a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13,\n    a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23,\n    a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23,\n    a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23,\n    a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23,\n    a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33,\n    a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33,\n    a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33,\n    a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33\n  ];\n}\n\n// src/math/mat4/mat4Perspective.ts\nfunction mat4Perspective(fov = 45, near = 0.01, far = 100) {\n  const p = 1 / Math.tan(fov * Math.PI / 360);\n  const d = far - near;\n  return [\n    p,\n    0,\n    0,\n    0,\n    0,\n    p,\n    0,\n    0,\n    0,\n    0,\n    -(far + near) / d,\n    -1,\n    0,\n    0,\n    -2 * far * near / d,\n    0\n  ];\n}\n\n// src/math/mat4/mat4RotateX.ts\nfunction mat4RotateX(theta) {\n  const c = Math.cos(theta);\n  const s = Math.sin(theta);\n  return [\n    1,\n    0,\n    0,\n    0,\n    0,\n    c,\n    -s,\n    0,\n    0,\n    s,\n    c,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4RotateY.ts\nfunction mat4RotateY(theta) {\n  const c = Math.cos(theta);\n  const s = Math.sin(theta);\n  return [\n    c,\n    0,\n    s,\n    0,\n    0,\n    1,\n    0,\n    0,\n    -s,\n    0,\n    c,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4RotateZ.ts\nfunction mat4RotateZ(theta) {\n  const c = Math.cos(theta);\n  const s = Math.sin(theta);\n  return [\n    c,\n    -s,\n    0,\n    0,\n    s,\n    c,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4Scale.ts\nfunction mat4Scale(vec) {\n  return [\n    vec[0],\n    0,\n    0,\n    0,\n    0,\n    vec[1],\n    0,\n    0,\n    0,\n    0,\n    vec[2],\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4ScaleScalar.ts\nfunction mat4ScaleScalar(scalar) {\n  return [\n    scalar,\n    0,\n    0,\n    0,\n    0,\n    scalar,\n    0,\n    0,\n    0,\n    0,\n    scalar,\n    0,\n    0,\n    0,\n    0,\n    1\n  ];\n}\n\n// src/math/mat4/mat4Translate.ts\nfunction mat4Translate(vec) {\n  return [\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    vec[0],\n    vec[1],\n    vec[2],\n    1\n  ];\n}\n\n// src/math/mat4/mat4Transpose.ts\nfunction mat4Transpose(m) {\n  return [\n    m[0],\n    m[4],\n    m[8],\n    m[12],\n    m[1],\n    m[5],\n    m[9],\n    m[13],\n    m[2],\n    m[6],\n    m[10],\n    m[14],\n    m[3],\n    m[7],\n    m[11],\n    m[15]\n  ];\n}\n\n// src/math/mat4/Matrix4.ts\nvar rawIdentityMatrix4 = [\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1\n];\nvar Matrix4 = class {\n  constructor(v = rawIdentityMatrix4) {\n    this.elements = v;\n  }\n  get transpose() {\n    return new Matrix4(mat4Transpose(this.elements));\n  }\n  get determinant() {\n    return mat4Determinant(this.elements);\n  }\n  get inverse() {\n    return new Matrix4(mat4Inverse(this.elements));\n  }\n  get matrix3() {\n    return Matrix3.fromMatrix4(this);\n  }\n  toString() {\n    const m = this.elements.map((v) => v.toFixed(3));\n    return `Matrix4( ${m[0]}, ${m[4]}, ${m[8]}, ${m[12]}; ${m[1]}, ${m[5]}, ${m[9]}, ${m[13]}; ${m[2]}, ${m[6]}, ${m[10]}, ${m[14]}; ${m[3]}, ${m[7]}, ${m[11]}, ${m[15]} )`;\n  }\n  clone() {\n    return new Matrix4(this.elements.concat());\n  }\n  multiply(...matrices) {\n    return Matrix4.multiply(this, ...matrices);\n  }\n  scaleScalar(scalar) {\n    return new Matrix4(vecScale(this.elements, scalar));\n  }\n  decompose() {\n    const { position, scale, rotation } = mat4Decompose(this.elements);\n    return {\n      position: new Vector3(position),\n      scale: new Vector3(scale),\n      rotation: new Quaternion(rotation)\n    };\n  }\n  static get identity() {\n    return new Matrix4(rawIdentityMatrix4);\n  }\n  static multiply(...matrices) {\n    if (matrices.length === 0) {\n      return Matrix4.identity;\n    } else {\n      return new Matrix4(mat4Multiply(...matrices.map((m) => m.elements)));\n    }\n  }\n  static fromQuaternion(quaternion) {\n    return new Matrix4(mat4FromQuaternion(quaternion.elements));\n  }\n  static fromMatrix3(matrix3) {\n    return new Matrix4(mat4FromMat3(matrix3.elements));\n  }\n  static translate(vector) {\n    return new Matrix4(mat4Translate(vector.elements));\n  }\n  static scale(vector) {\n    return new Matrix4(mat4Scale(vector.elements));\n  }\n  static scaleScalar(scalar) {\n    return new Matrix4(mat4ScaleScalar(scalar));\n  }\n  static rotateX(theta) {\n    return new Matrix4(mat4RotateX(theta));\n  }\n  static rotateY(theta) {\n    return new Matrix4(mat4RotateY(theta));\n  }\n  static rotateZ(theta) {\n    return new Matrix4(mat4RotateZ(theta));\n  }\n  static lookAt(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {\n    return new Matrix4(mat4LookAt(position.elements, target.elements, up.elements, roll));\n  }\n  static lookAtInverse(position, target = new Vector3([0, 0, 0]), up = new Vector3([0, 1, 0]), roll = 0) {\n    return new Matrix4(mat4LookAtInverse(position.elements, target.elements, up.elements, roll));\n  }\n  static perspective(fov = 45, near = 0.01, far = 100) {\n    return new Matrix4(mat4Perspective(fov, near, far));\n  }\n  static compose(position, rotation, scale) {\n    return new Matrix4(mat4Compose(position.elements, rotation.elements, scale.elements));\n  }\n};\n\n// src/math/quat/quatFromAxisAngle.ts\nfunction quatFromAxisAngle(axis, angle) {\n  const halfAngle = angle / 2;\n  const sinHalfAngle = Math.sin(halfAngle);\n  return [\n    axis[0] * sinHalfAngle,\n    axis[1] * sinHalfAngle,\n    axis[2] * sinHalfAngle,\n    Math.cos(halfAngle)\n  ];\n}\n\n// src/math/quat/quatLookRotation.ts\nfunction quatLookRotation(look, up) {\n  const { normal, tangent, binormal } = vec3OrthoNormalize(look, up != null ? up : [0, 1, 0]);\n  const w = Math.sqrt(1 + binormal[0] + tangent[1] + normal[2]) * 0.5;\n  const invW4 = 0.25 / w;\n  return [\n    (tangent[2] - normal[1]) * invW4,\n    (normal[0] - binormal[2]) * invW4,\n    (binormal[1] - tangent[0]) * invW4,\n    w\n  ];\n}\n\n// src/math/quat/quatNormalize.ts\nfunction quatNormalize(vec) {\n  const len = vecLength(vec);\n  if (len === 0) {\n    return [0, 0, 0, 1];\n  }\n  return vecScale(vec, 1 / len);\n}\n\n// src/math/quat/quatSlerp.ts\nfunction quatSlerp(a, b, t) {\n  if (t === 0) {\n    return a.concat();\n  }\n  if (t === 1) {\n    return b.concat();\n  }\n  let cosHalfTheta = vecDot(a, b);\n  if (cosHalfTheta < 0) {\n    b = vecNeg(b);\n    cosHalfTheta = -cosHalfTheta;\n  }\n  if (cosHalfTheta >= 1) {\n    return a.concat();\n  }\n  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n  if (sqrSinHalfTheta <= Number.EPSILON) {\n    const s = 1 - t;\n    return vecNormalize([\n      s * a[0] + t * b[0],\n      s * a[1] + t * b[1],\n      s * a[2] + t * b[2],\n      s * a[3] + t * b[3]\n    ]);\n  }\n  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;\n  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n  return [\n    a[0] * ratioA + b[0] * ratioB,\n    a[1] * ratioA + b[1] * ratioB,\n    a[2] * ratioA + b[2] * ratioB,\n    a[3] * ratioA + b[3] * ratioB\n  ];\n}\n\n// src/math/quat/Quaternion.ts\nvar rawIdentityQuaternion = [0, 0, 0, 1];\nvar Quaternion = class {\n  constructor(elements = rawIdentityQuaternion) {\n    this.elements = elements;\n  }\n  get x() {\n    return this.elements[0];\n  }\n  get y() {\n    return this.elements[1];\n  }\n  get z() {\n    return this.elements[2];\n  }\n  get w() {\n    return this.elements[3];\n  }\n  toString() {\n    return `Quaternion( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;\n  }\n  clone() {\n    return new Quaternion(this.elements.concat());\n  }\n  get matrix4() {\n    return new Matrix4(mat4FromQuaternion(this.elements));\n  }\n  get inversed() {\n    return new Quaternion(quatInverse(this.elements));\n  }\n  get length() {\n    return vecLength(this.elements);\n  }\n  get lengthSq() {\n    return vecLengthSq(this.elements);\n  }\n  get normalized() {\n    return new Quaternion(quatNormalize(this.elements));\n  }\n  multiply(...quaternions) {\n    return Quaternion.multiply(this, ...quaternions);\n  }\n  slerp(b, t) {\n    return Quaternion.slerp(this, b, t);\n  }\n  static get identity() {\n    return new Quaternion(rawIdentityQuaternion);\n  }\n  static multiply(...quaternions) {\n    if (quaternions.length === 0) {\n      return Quaternion.identity;\n    } else {\n      return new Quaternion(quatMultiply(...quaternions.map((q) => q.elements)));\n    }\n  }\n  static slerp(a, b, t) {\n    return new Quaternion(quatSlerp(a.elements, b.elements, t));\n  }\n  static lookRotation(look, up) {\n    return new Quaternion(quatLookRotation(look.elements, up.elements));\n  }\n  static fromAxisAngle(axis, angle) {\n    return new Quaternion(quatFromAxisAngle(axis.elements, angle));\n  }\n  static fromMatrix4(matrix) {\n    return new Quaternion(quatFromMatrix4(matrix.elements));\n  }\n};\n\n// src/math/mod.ts\nfunction _0b5vr_experimental_esm_mod(value, divisor) {\n  return value - Math.floor(value / divisor) * divisor;\n}\n\n// src/math/sanitizeAngle.ts\nfunction sanitizeAngle(angle) {\n  return _0b5vr_experimental_esm_mod(angle + Math.PI, 2 * Math.PI) - Math.PI;\n}\n\n// src/math/euler/eulerFromMat3.ts\nfunction eulerFromMat3(m, order) {\n  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];\n  const result = [0, 0, 0];\n  const c = m[k + i * 3];\n  result[j] = -sign * Math.asin(_0b5vr_experimental_esm_clamp(c, -1, 1));\n  if (Math.abs(c) < 0.999999) {\n    result[i] = sign * Math.atan2(m[k + j * 3], m[k * 4]);\n    result[k] = sign * Math.atan2(m[j + i * 3], m[i * 4]);\n  } else {\n    result[i] = sign * Math.atan2(-m[j + k * 3], m[j * 4]);\n  }\n  if (vecManhattanLength(result) > 1.5 * Math.PI) {\n    result[i] = sanitizeAngle(result[i] + Math.PI);\n    result[j] = sanitizeAngle(Math.PI - result[j]);\n    result[k] = sanitizeAngle(result[k] + Math.PI);\n  }\n  return result;\n}\n\n// src/math/euler/eulerFromMat4.ts\nfunction eulerFromMat4(m, order) {\n  return eulerFromMat3(mat3FromMat4(m), order);\n}\n\n// src/math/euler/eulerFromQuaternion.ts\nfunction eulerFromQuaternion(m, order) {\n  return eulerFromMat3(mat3FromQuaternion(m), order);\n}\n\n// src/math/quat/quatFromEuler.ts\nfunction quatFromEuler(euler, order) {\n  const [i, j, k, sign] = !order || order === "XYZ" ? [0, 1, 2, 1] : order === "XZY" ? [0, 2, 1, -1] : order === "YXZ" ? [1, 0, 2, -1] : order === "YZX" ? [1, 2, 0, 1] : order === "ZXY" ? [2, 0, 1, 1] : [2, 1, 0, -1];\n  const ti = 0.5 * euler[i];\n  const tj = 0.5 * sign * euler[j];\n  const tk = 0.5 * euler[k];\n  const ci = Math.cos(ti);\n  const cj = Math.cos(tj);\n  const ck = Math.cos(tk);\n  const si = Math.sin(ti);\n  const sj = Math.sin(tj);\n  const sk = Math.sin(tk);\n  const result = [\n    0,\n    0,\n    0,\n    ck * cj * ci + sk * sj * si\n  ];\n  result[i] = ck * cj * si - sk * sj * ci;\n  result[j] = sign * (ck * sj * ci + sk * cj * si);\n  result[k] = sk * cj * ci - ck * sj * si;\n  return result;\n}\n\n// src/math/euler/Euler.ts\nvar Euler = class {\n  constructor(elements = [0, 0, 0], order = "XYZ") {\n    this.elements = elements;\n    this.order = order;\n  }\n  get x() {\n    return this.elements[0];\n  }\n  get y() {\n    return this.elements[1];\n  }\n  get z() {\n    return this.elements[2];\n  }\n  toString() {\n    return `Euler( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)} (${this.order}) )`;\n  }\n  clone() {\n    return new Euler(this.elements.concat(), this.order);\n  }\n  get quaternion() {\n    return new Quaternion(quatFromEuler(this.elements, this.order));\n  }\n  get matrix4() {\n    return this.quaternion.matrix4;\n  }\n  static fromMatrix3(matrix, order) {\n    return new Euler(eulerFromMat3(matrix.elements, order), order);\n  }\n  static fromMatrix4(matrix, order) {\n    return new Euler(eulerFromMat4(matrix.elements, order), order);\n  }\n  static fromQuaternion(quaternion, order) {\n    return new Euler(eulerFromQuaternion(quaternion.elements, order), order);\n  }\n};\n\n// src/math/mat3/mat3FromMat4Transpose.ts\nfunction mat3FromMat4Transpose(source) {\n  return [\n    source[0],\n    source[4],\n    source[8],\n    source[1],\n    source[5],\n    source[9],\n    source[2],\n    source[6],\n    source[10]\n  ];\n}\n\n// src/math/vec4/Vector4.ts\nvar Vector4 = class extends Vector {\n  constructor(v = [0, 0, 0, 0]) {\n    super();\n    this.elements = v;\n  }\n  get x() {\n    return this.elements[0];\n  }\n  set x(x) {\n    this.elements[0] = x;\n  }\n  get y() {\n    return this.elements[1];\n  }\n  set y(y) {\n    this.elements[1] = y;\n  }\n  get z() {\n    return this.elements[2];\n  }\n  set z(z) {\n    this.elements[2] = z;\n  }\n  get w() {\n    return this.elements[3];\n  }\n  set w(z) {\n    this.elements[3] = z;\n  }\n  toString() {\n    return `Vector4( ${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)} )`;\n  }\n  applyMatrix4(matrix) {\n    return new Vector4(vec4ApplyMatrix4(this.elements, matrix.elements));\n  }\n  __new(v) {\n    return new Vector4(v);\n  }\n  static get zero() {\n    return new Vector4([0, 0, 0, 0]);\n  }\n  static get one() {\n    return new Vector4([1, 1, 1, 1]);\n  }\n};\n\n// src/poker/pokerRanksByStrength.ts\nvar pokerRanksByStrength = (/* unused pure expression or super */ null && ([\n  "2",\n  "3",\n  "4",\n  "5",\n  "6",\n  "7",\n  "8",\n  "9",\n  "T",\n  "J",\n  "Q",\n  "K",\n  "A"\n]));\n\n// src/poker/pokerSuitsByIndex.ts\nvar pokerSuitsByIndex = (/* unused pure expression or super */ null && ([\n  "c",\n  "d",\n  "h",\n  "s"\n]));\n\n// src/poker/createPokerDeck.ts\nfunction createPokerDeck() {\n  const array = [];\n  pokerSuitsByIndex.map((suit) => pokerRanksByStrength.map((rank) => array.push(rank + suit)));\n  return array;\n}\n\n// src/poker/pokerHandStrengthMap.ts\nvar pokerHandStrengthMap = {\n  "HighCard": 0,\n  "OnePair": 1,\n  "TwoPair": 2,\n  "ThreeOfAKind": 3,\n  "Straight": 4,\n  "Flush": 5,\n  "FullHouse": 6,\n  "FourOfAKind": 7,\n  "StraightFlush": 8\n};\n\n// src/poker/pokerRankStrengthMap.ts\nvar pokerRankStrengthMap = {\n  "2": 0,\n  "3": 1,\n  "4": 2,\n  "5": 3,\n  "6": 4,\n  "7": 5,\n  "8": 6,\n  "9": 7,\n  "T": 8,\n  "J": 9,\n  "Q": 10,\n  "K": 11,\n  "A": 12\n};\n\n// src/poker/pokerSuitIndexMap.ts\nvar pokerSuitIndexMap = {\n  "c": 0,\n  "d": 1,\n  "h": 2,\n  "s": 3\n};\n\n// src/poker/sortPokerCardsByRank.ts\nfunction sortPokerCardsByRank(cards) {\n  return cards.sort((a, b) => pokerSuitIndexMap[a[1]] - pokerSuitIndexMap[b[1]]).sort((a, b) => pokerRankStrengthMap[a[0]] - pokerRankStrengthMap[b[0]]);\n}\n\n// src/poker/evaluatePokerHand.ts\nfunction evaluatePokerHand(cards) {\n  const cards_ = cards.concat();\n  const cardsByRank = new MapOfSet();\n  const cardsBySuit = new MapOfSet();\n  cards_.map((card) => {\n    const rank = card[0];\n    const suit = card[1];\n    cardsByRank.add(rank, card);\n    cardsBySuit.add(suit, card);\n  });\n  const fours = [];\n  const threes = [];\n  const twos = [];\n  pokerRanksByStrength.map((rank) => {\n    const cards2 = cardsByRank.get(rank);\n    if (cards2.size > 3) {\n      fours.push(rank);\n    } else if (cards2.size > 2) {\n      threes.push(rank);\n    } else if (cards2.size > 1) {\n      twos.push(rank);\n    }\n  });\n  let straightCards;\n  {\n    let current = [];\n    const a = Array.from(cardsByRank.get("A"))[0];\n    if (a) {\n      current.push(a);\n    }\n    pokerRanksByStrength.map((rank) => {\n      const card = Array.from(cardsByRank.get(rank))[0];\n      if (card) {\n        current.push(card);\n        if (current.length > 4) {\n          straightCards = current;\n        }\n      } else {\n        current = [];\n      }\n    });\n  }\n  if (straightCards) {\n    for (const [suit, cardsSet] of cardsBySuit.map) {\n      if (cardsSet.size > 0) {\n        let straightFlushCards;\n        let current = [];\n        const target = "A" + suit;\n        const a = cardsSet.has(target);\n        if (a) {\n          current.push(target);\n        }\n        pokerRanksByStrength.map((rank) => {\n          const target2 = rank + suit;\n          if (cardsSet.has(target2)) {\n            current.push(target2);\n            if (current.length > 4) {\n              straightFlushCards = current;\n            }\n          } else {\n            current = [];\n          }\n        });\n        if (straightFlushCards) {\n          straightFlushCards.splice(0, straightFlushCards.length - 5);\n          const hand = "StraightFlush";\n          const strength = [\n            pokerHandStrengthMap[hand],\n            pokerRankStrengthMap[straightFlushCards[4][0]]\n          ];\n          return {\n            hand,\n            cards: straightFlushCards,\n            strength\n          };\n        }\n      }\n    }\n  }\n  if (fours.length > 0) {\n    fours.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);\n    fours.splice(0, fours.length - 1);\n    const sameCards = Array.from(cardsByRank.get(fours[0]));\n    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));\n    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);\n    const hand = "FourOfAKind";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[fours[0]],\n      pokerRankStrengthMap[cards_[0][0]]\n    ];\n    cards_.push(...sameCards);\n    sortPokerCardsByRank(cards_);\n    return {\n      hand,\n      cards: cards_,\n      strength\n    };\n  }\n  if (threes.length > 0 && threes.length + twos.length > 1) {\n    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);\n    twos.push(...threes.splice(0, threes.length - 1));\n    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);\n    twos.splice(0, twos.length - 1);\n    const sameCards = Array.from(cardsByRank.get(threes[0]));\n    sameCards.push(...Array.from(cardsByRank.get(twos[0])));\n    sortPokerCardsByRank(sameCards).splice(0, sameCards.length - 5);\n    const hand = "FullHouse";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[threes[0]],\n      pokerRankStrengthMap[twos[0]]\n    ];\n    return {\n      hand,\n      cards: sameCards,\n      strength\n    };\n  }\n  for (const [_suit, cardsSet] of cardsBySuit.map) {\n    if (cardsSet.size > 4) {\n      const cards2 = sortPokerCardsByRank(Array.from(cardsSet));\n      cards2.splice(0, cards2.length - 5);\n      const hand = "Flush";\n      const strength = [\n        pokerHandStrengthMap[hand],\n        ...cards2.concat().reverse().map((card) => pokerRankStrengthMap[card[0]])\n      ];\n      return {\n        hand,\n        cards: cards2,\n        strength\n      };\n    }\n  }\n  if (straightCards) {\n    straightCards.splice(0, straightCards.length - 5);\n    const hand = "Straight";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[straightCards[4][0]]\n    ];\n    return {\n      hand,\n      cards: straightCards,\n      strength\n    };\n  }\n  if (threes.length > 0) {\n    threes.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);\n    threes.splice(0, threes.length - 1);\n    const sameCards = Array.from(cardsByRank.get(threes[0]));\n    sameCards.map((card) => cards_.splice(cards_.indexOf(card), 1));\n    sortPokerCardsByRank(cards_).splice(0, cards_.length - 2);\n    const hand = "ThreeOfAKind";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[threes[0]],\n      pokerRankStrengthMap[cards_[1][0]],\n      pokerRankStrengthMap[cards_[0][0]]\n    ];\n    cards_.push(...sameCards);\n    sortPokerCardsByRank(cards_);\n    return {\n      hand,\n      cards: cards_,\n      strength\n    };\n  }\n  if (twos.length > 1) {\n    twos.sort((a, b) => pokerRankStrengthMap[a] - pokerRankStrengthMap[b]);\n    twos.splice(0, twos.length - 2);\n    const pairs = Array.from(cardsByRank.get(twos[0]));\n    pairs.push(...Array.from(cardsByRank.get(twos[1])));\n    pairs.map((card) => cards_.splice(cards_.indexOf(card), 1));\n    sortPokerCardsByRank(cards_).splice(0, cards_.length - 1);\n    const hand = "TwoPair";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[twos[1]],\n      pokerRankStrengthMap[twos[0]],\n      pokerRankStrengthMap[cards_[0][0]]\n    ];\n    cards_.push(...pairs);\n    sortPokerCardsByRank(cards_);\n    return {\n      hand,\n      cards: cards_,\n      strength\n    };\n  }\n  if (twos.length > 0) {\n    const pair = Array.from(cardsByRank.get(twos[0]));\n    pair.map((card) => cards_.splice(cards_.indexOf(card), 1));\n    sortPokerCardsByRank(cards_).splice(0, cards_.length - 3);\n    const hand = "OnePair";\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[twos[0]],\n      pokerRankStrengthMap[cards_[2][0]],\n      pokerRankStrengthMap[cards_[1][0]],\n      pokerRankStrengthMap[cards_[0][0]]\n    ];\n    cards_.push(...pair);\n    sortPokerCardsByRank(cards_);\n    return {\n      hand,\n      cards: cards_,\n      strength\n    };\n  }\n  {\n    const hand = "HighCard";\n    sortPokerCardsByRank(cards_);\n    cards_.splice(0, cards_.length - 5);\n    const strength = [\n      pokerHandStrengthMap[hand],\n      pokerRankStrengthMap[cards_[4][0]],\n      pokerRankStrengthMap[cards_[3][0]],\n      pokerRankStrengthMap[cards_[2][0]],\n      pokerRankStrengthMap[cards_[1][0]],\n      pokerRankStrengthMap[cards_[0][0]]\n    ];\n    return {\n      hand,\n      cards: cards_,\n      strength\n    };\n  }\n}\n\n// src/poker/pokerHandsByStrength.ts\nvar pokerHandsByStrength = (/* unused pure expression or super */ null && ([\n  "HighCard",\n  "OnePair",\n  "TwoPair",\n  "ThreeOfAKind",\n  "Straight",\n  "Flush",\n  "FullHouse",\n  "FourOfAKind",\n  "StraightFlush"\n]));\n\n// src/Swap/Swap.ts\nvar Swap = class {\n  constructor(a, b) {\n    this.i = a;\n    this.o = b;\n  }\n  swap() {\n    const i = this.i;\n    this.i = this.o;\n    this.o = i;\n  }\n};\n\n// src/TapTempo/TapTempo.ts\nvar TapTempo = class {\n  constructor() {\n    this.__bpm = 0;\n    this.__lastTap = 0;\n    this.__lastBeat = 0;\n    this.__lastTime = 0;\n    this.__calc = new HistoryMeanCalculator(16);\n  }\n  get beatDuration() {\n    return 60 / this.__bpm;\n  }\n  get bpm() {\n    return this.__bpm;\n  }\n  set bpm(bpm) {\n    this.__lastBeat = this.beat;\n    this.__lastTime = performance.now();\n    this.__bpm = bpm;\n  }\n  get beat() {\n    return this.__lastBeat + (performance.now() - this.__lastTime) * 1e-3 / this.beatDuration;\n  }\n  reset() {\n    this.__calc.reset();\n  }\n  nudge(amount) {\n    this.__lastBeat = this.beat + amount;\n    this.__lastTime = performance.now();\n  }\n  tap() {\n    const now = performance.now();\n    const delta = (now - this.__lastTap) * 1e-3;\n    if (2 < delta) {\n      this.reset();\n    } else {\n      this.__calc.push(delta);\n      this.__bpm = 60 / this.__calc.mean;\n    }\n    this.__lastTap = now;\n    this.__lastTime = now;\n    this.__lastBeat = 0;\n  }\n};\n\n// src/Xorshift/Xorshift.ts\nvar Xorshift = class {\n  constructor(seed) {\n    this.seed = seed || 1;\n  }\n  gen(seed) {\n    if (seed) {\n      this.seed = seed;\n    }\n    this.seed = this.seed ^ this.seed << 13;\n    this.seed = this.seed ^ this.seed >>> 17;\n    this.seed = this.seed ^ this.seed << 5;\n    return this.seed / Math.pow(2, 32) + 0.5;\n  }\n  set(seed) {\n    this.seed = seed || this.seed || 1;\n  }\n};\n\n// src/yugop/getYugopText.ts\nfunction getYugopText(text, phase, randomRatio = 0.5) {\n  if (phase >= 1) {\n    return text;\n  }\n  if (phase < 0) {\n    return "";\n  }\n  const displayTween = _0b5vr_experimental_esm_linearstep(0, 1 - randomRatio, phase);\n  const fixTween = _0b5vr_experimental_esm_linearstep(randomRatio, 1, phase);\n  const displayLength = 1 + Math.floor(displayTween * (text.length - 1));\n  const fixLength = phase < randomRatio ? 0 : 1 + Math.floor(fixTween * (text.length - 1));\n  const randomLength = displayLength - fixLength;\n  const randomStr = [...Array(randomLength)].map(() => String.fromCharCode(33 + Math.floor(93 * Math.random()))).join("");\n  return text.substring(0, fixLength) + randomStr;\n}\n\n//# sourceMappingURL=0b5vr-experimental.esm.js.map\n\n;// CONCATENATED MODULE: ./src/utils/wtexture.ts\n\r\n\r\n\r\nclass Texture {\r\n    constructor(args) {\r\n        this.attachedFramebuffers = [];\r\n        (async () => {\r\n            args.width = ifExistsAElseB(args.width, Sketch.wgpu.width);\r\n            args.height = ifExistsAElseB(args.height, Sketch.wgpu.height);\r\n            args.depth = ifExistsAElseB(args.depth, 1);\r\n            args.usage = ifExistsAElseB(args.usage, args.depthTex ?\r\n                GPUTextureUsage.RENDER_ATTACHMENT :\r\n                GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST);\r\n            args.format = ifExistsAElseB(args.format, args.depthTex ?\r\n                "depth24plus" : "rgba32float");\r\n            if (args.framebuffer)\r\n                this.attachedFramebuffers.push(args.framebuffer);\r\n            this.width = args.width;\r\n            this.height = args.height;\r\n            this.depth = args.depth;\r\n            this.props = args;\r\n            this.create();\r\n            Texture.textures.push(this);\r\n            return Promise.resolve();\r\n        })();\r\n    }\r\n    create() {\r\n        const props = this.props;\r\n        const textureDesc = {\r\n            size: [this.width, this.height],\r\n            format: props.format,\r\n            usage: props.usage\r\n        };\r\n        const tex = Sketch.wgpu.device.createTexture(textureDesc);\r\n        const texView = tex.createView();\r\n        this.texture = tex;\r\n        this.view = texView;\r\n    }\r\n    static fromArray({ data }) {\r\n        let canvas = document.createElement("canvas");\r\n        canvas.width = data.length;\r\n        canvas.height = data[0].length;\r\n        document.body.appendChild(canvas);\r\n        canvas.style.opacity = "0";\r\n        const imageData = canvas.getContext("2d").createImageData(canvas.width, canvas.height);\r\n        loop(imageData.height, y => {\r\n            loop(imageData.width, x => {\r\n                const index = (x + y * imageData.width);\r\n                const inputPix = data[y][x];\r\n                imageData.data[index * 4 + 0] = inputPix.x * 255;\r\n                imageData.data[index * 4 + 1] = inputPix.y * 255;\r\n                imageData.data[index * 4 + 2] = inputPix.z * 255;\r\n                imageData.data[index * 4 + 3] = inputPix.w * 255;\r\n            });\r\n        });\r\n        canvas.getContext("2d").putImageData(imageData, 0, 0);\r\n        const tex = new Texture({\r\n            width: canvas.width,\r\n            height: canvas.height,\r\n            format: "rgba8unorm"\r\n        });\r\n        Sketch.wgpu.device.queue.copyExternalImageToTexture({ source: canvas }, { texture: tex.texture }, [canvas.width, canvas.height]);\r\n        document.body.removeChild(canvas);\r\n        canvas = null;\r\n        return tex;\r\n    }\r\n    clear(colour = new Vector4([0, 0, 0, 0])) {\r\n        const passDescriptor = {\r\n            colorAttachments: [{\r\n                    view: this.view,\r\n                    clearValue: { r: colour.x, g: colour.y, b: colour.z, a: colour.w },\r\n                    loadOp: "clear",\r\n                    storeOp: "store",\r\n                }]\r\n        };\r\n        const commandEncoder = Sketch.wgpu.device.createCommandEncoder();\r\n        const passEncoder = commandEncoder.beginRenderPass(passDescriptor);\r\n        Sketch.wgpu.encoderPasses.push({\r\n            commandEncoder,\r\n            passEncoder,\r\n        });\r\n    }\r\n    resize(width, height, depth) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = ifExistsAElseB(depth, this.depth);\r\n        if (this.defaultTex) {\r\n            const defaultTex = Sketch.wgpu.context.getCurrentTexture();\r\n            const defaultTexView = defaultTex.createView();\r\n            this.texture = defaultTex;\r\n            this.view = defaultTexView;\r\n        }\r\n        else {\r\n            this.texture.destroy();\r\n            this.create();\r\n        }\r\n        for (let framebuffer of this.attachedFramebuffers) {\r\n            framebuffer.refresh();\r\n        }\r\n    }\r\n}\r\nTexture.textures = [];\r\n\n;// CONCATENATED MODULE: ./src/utils/wframebuffer.ts\n\r\n\r\n\r\n\r\nclass FrameBuffer {\r\n    constructor({ resolution, depth, attachmentsCnt, format }) {\r\n        this.textures = [];\r\n        attachmentsCnt = ifExistsAElseB(attachmentsCnt, 1);\r\n        resolution = ifExistsAElseB(attachmentsCnt, new Vec3(Sketch.wgpu.width, Sketch.wgpu.height, 1));\r\n        let colorAttachments = [];\r\n        loop(attachmentsCnt, i => {\r\n            const tex = new Texture({ width: resolution.x, height: resolution.y, framebuffer: this, format });\r\n            this.textures.push(tex);\r\n            colorAttachments.push({\r\n                view: tex.view,\r\n                clearValue: { r: 0, g: 0, b: 0, a: 1 },\r\n                loadOp: "clear",\r\n                storeOp: "store",\r\n            });\r\n        });\r\n        this.renderPassDescriptor = {\r\n            colorAttachments: colorAttachments\r\n        };\r\n        if (depth) {\r\n            this.depthTexture = new Texture({ width: resolution.x, height: resolution.y, depth: resolution.z, depthTex: true, framebuffer: this });\r\n            this.renderPassDescriptor.depthStencilAttachment = {\r\n                view: this.depthTexture.view,\r\n                depthClearValue: 1,\r\n                depthLoadOp: "clear",\r\n                depthStoreOp: \'store\',\r\n                stencilClearValue: 0,\r\n                stencilLoadOp: "clear",\r\n                stencilStoreOp: \'store\',\r\n            };\r\n        }\r\n    }\r\n    refresh() {\r\n        let i = 0;\r\n        const rpDescriptor = this.renderPassDescriptor;\r\n        for (let colorAttachment of rpDescriptor.colorAttachments) {\r\n            const tex = this.textures[i];\r\n            colorAttachment.view = tex.view;\r\n            i++;\r\n        }\r\n        if (this.depthTexture)\r\n            rpDescriptor.depthStencilAttachment.view = this.depthTexture.view;\r\n    }\r\n    startPass(endLastPass = true) {\r\n        if (endLastPass) {\r\n            Sketch.wgpu.flushPasses();\r\n        }\r\n        this.commandEncoder = Sketch.wgpu.device.createCommandEncoder();\r\n        this.passEncoder = this.commandEncoder.beginRenderPass(this.renderPassDescriptor);\r\n        Sketch.wgpu.encoderPasses.push({\r\n            commandEncoder: this.commandEncoder,\r\n            passEncoder: this.passEncoder,\r\n            framebuffer: this\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wstoragebuffer.ts\n\r\n\r\nclass StorageBuffer {\r\n    constructor() {\r\n        this.totalFloatSz = 0;\r\n    }\r\n    get buff() {\r\n        return this._buff;\r\n    }\r\n    create(size = 1400, usage = GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC, array, mapped = false, uniform = false) {\r\n        this.type = uniform ? "uniform" : "storage";\r\n        if (array) {\r\n            if (array instanceof Float32Array) {\r\n                this.mappedArr = new Float32Array(array.length);\r\n                this.mappedArr.set(array);\r\n            }\r\n            else if (array instanceof Int32Array) {\r\n                this.mappedArr = new Int32Array(array.length);\r\n                this.mappedArr.set(array);\r\n            }\r\n        }\r\n        else\r\n            this.mappedArr = new Float32Array(size);\r\n        this.totalFloatSz = size;\r\n        this._buff = Sketch.wgpu.device.createBuffer({\r\n            mappedAtCreation: true, size: size * 4, usage,\r\n        });\r\n        let arrayBuffer = this._buff.getMappedRange();\r\n        new Float32Array(arrayBuffer).set(this.mappedArr);\r\n        this._buff.unmap();\r\n        return this;\r\n    }\r\n    uploadMapped() {\r\n        Sketch.wgpu.queue.writeBuffer(this.buff, 0, this.mappedArr.buffer, 0, this.mappedArr.buffer.byteLength);\r\n    }\r\n    clear(endLastPass = true, offset, size) {\r\n        offset = ifExistsAElseB(offset, 0);\r\n        size = ifExistsAElseB(this.mappedArr.buffer.byteLength, 0);\r\n        if (endLastPass) {\r\n            Sketch.wgpu.flushPasses();\r\n        }\r\n        const commandEncoder = Sketch.wgpu.device.createCommandEncoder();\r\n        Sketch.wgpu.encoderPasses.push({\r\n            commandEncoder: commandEncoder,\r\n        });\r\n        commandEncoder.clearBuffer(this.buff, offset, size);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wabstractbindingcontainer.ts\n\r\n\r\n\r\nclass AbstractBindingContainer {\r\n    constructor() {\r\n        this.bindGroups = [Sketch.sharedUBO.bindGroup, Sketch.sharedUBO.bindGroup, Sketch.sharedUBO.bindGroup, Sketch.sharedUBO.bindGroup];\r\n        this.bindGroupLayouts = [Sketch.sharedUBO.bindGroupLayout, Sketch.sharedUBO.bindGroupLayout, Sketch.sharedUBO.bindGroupLayout, Sketch.sharedUBO.bindGroupLayout];\r\n        this.uniformTextures = {};\r\n        this.uniformWritables = {};\r\n        this.pipelineNeedsRefresh = false;\r\n        let i = 0;\r\n        for (let bindGroup of this.bindGroups) {\r\n            this.bindGroups[i] = Sketch.sharedBindGroup.bindGroup;\r\n            this.bindGroupLayouts[i] = Sketch.sharedBindGroup.bindGroupLayout;\r\n            i++;\r\n        }\r\n    }\r\n    refreshWritable() {\r\n        let bindGroupLayoutEntries = [];\r\n        let bindGroupEntries = [];\r\n        for (let [idx, writableObj] of Object.entries(this.uniformWritables)) {\r\n            if (writableObj instanceof StorageBuffer) {\r\n                bindGroupLayoutEntries.push({\r\n                    binding: parseInt(idx),\r\n                    visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\r\n                    buffer: {\r\n                        type: "storage"\r\n                    }\r\n                });\r\n                bindGroupEntries.push({\r\n                    binding: parseInt(idx),\r\n                    resource: {\r\n                        buffer: writableObj.buff,\r\n                        size: writableObj.mappedArr.byteLength,\r\n                        offset: 0\r\n                    }\r\n                });\r\n            }\r\n            else if (writableObj instanceof Texture) {\r\n                bindGroupLayoutEntries.push({\r\n                    binding: parseInt(idx),\r\n                    visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\r\n                    storageTexture: {\r\n                        format: writableObj.props.format,\r\n                        access: "write-only"\r\n                    }\r\n                });\r\n                bindGroupEntries.push({\r\n                    binding: parseInt(idx),\r\n                    resource: writableObj.view\r\n                });\r\n            }\r\n        }\r\n        this.bindGroupLayouts[3] = Sketch.wgpu.device.createBindGroupLayout({\r\n            entries: bindGroupLayoutEntries\r\n        });\r\n        this.bindGroups[3] = Sketch.wgpu.device.createBindGroup({\r\n            layout: this.bindGroupLayouts[3],\r\n            entries: bindGroupEntries\r\n        });\r\n        this.pipelineNeedsRefresh = true;\r\n    }\r\n    setWritable(thing, idx) {\r\n        this.uniformWritables[idx] = thing;\r\n        this.refreshWritable();\r\n    }\r\n    setWritables(storageBuffers) {\r\n        let i = 0;\r\n        for (let buff of storageBuffers) {\r\n            this.uniformWritables[i] = buff;\r\n            i++;\r\n        }\r\n        this.refreshWritable();\r\n    }\r\n    setUbos(uniformBuffers) {\r\n        this.uniformBuffers = uniformBuffers;\r\n        let bindGroupLayoutEntries = [];\r\n        let bindGroupEntries = [];\r\n        let i = 0;\r\n        for (let uniformBuffer of uniformBuffers) {\r\n            bindGroupLayoutEntries.push({\r\n                binding: i,\r\n                visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\r\n                buffer: {\r\n                    type: "uniform"\r\n                }\r\n            });\r\n            bindGroupEntries.push({\r\n                binding: i,\r\n                resource: {\r\n                    buffer: uniformBuffer.buff,\r\n                }\r\n            });\r\n            i++;\r\n        }\r\n        this.bindGroupLayouts[1] = Sketch.wgpu.device.createBindGroupLayout({\r\n            entries: bindGroupLayoutEntries\r\n        });\r\n        this.bindGroups[1] = Sketch.wgpu.device.createBindGroup({\r\n            layout: this.bindGroupLayouts[1],\r\n            entries: bindGroupEntries\r\n        });\r\n        this.pipelineNeedsRefresh = true;\r\n    }\r\n    refreshPipeline() {\r\n        this.pipelineDescriptor.layout = Sketch.wgpu.device.createPipelineLayout({\r\n            bindGroupLayouts: this.bindGroupLayouts\r\n        });\r\n        if (this.pipelineDescriptor.vertex) {\r\n            this.pipeline = Sketch.wgpu.device.createRenderPipeline(this.pipelineDescriptor);\r\n        }\r\n        else if (this.pipelineDescriptor.compute) {\r\n            this.pipeline = Sketch.wgpu.device.createComputePipeline(this.pipelineDescriptor);\r\n        }\r\n        else {\r\n            throw "uuuh";\r\n        }\r\n        this.pipelineNeedsRefresh = false;\r\n    }\r\n    setTexture(texture, idx) {\r\n        this.uniformTextures[idx] = texture;\r\n        this.refreshTextures();\r\n    }\r\n    setTextures(uniformTextures) {\r\n        let i = 1;\r\n        for (let texture of uniformTextures) {\r\n            this.uniformTextures[i] = texture;\r\n            i++;\r\n        }\r\n        this.refreshTextures();\r\n    }\r\n    refreshTextures() {\r\n        let bindGroupLayoutEntries = [];\r\n        let bindGroupEntries = [];\r\n        const sampler = Sketch.wgpu.device.createSampler({\r\n            magFilter: "linear",\r\n            minFilter: "linear",\r\n        });\r\n        bindGroupEntries.push({\r\n            binding: 0,\r\n            resource: sampler\r\n        });\r\n        bindGroupLayoutEntries.push({\r\n            binding: 0,\r\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\r\n            sampler: {\r\n                type: "filtering"\r\n            }\r\n        });\r\n        for (let [idx, tex] of Object.entries(this.uniformTextures)) {\r\n            bindGroupLayoutEntries.push({\r\n                binding: parseInt(idx),\r\n                visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX,\r\n                texture: {\r\n                    sampleType: "float",\r\n                },\r\n            });\r\n            bindGroupEntries.push({\r\n                binding: parseInt(idx),\r\n                resource: tex.view\r\n            });\r\n        }\r\n        this.bindGroupLayouts[2] = Sketch.wgpu.device.createBindGroupLayout({\r\n            entries: bindGroupLayoutEntries\r\n        });\r\n        this.bindGroups[2] = Sketch.wgpu.device.createBindGroup({\r\n            layout: this.bindGroupLayouts[2],\r\n            entries: bindGroupEntries\r\n        });\r\n        this.pipelineNeedsRefresh = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wthing.ts\n\r\n\r\nclass Thing extends AbstractBindingContainer {\r\n    constructor(vertexBuffer, shader) {\r\n        super();\r\n        this.vertexBuffers = [];\r\n        this.lastFB = null;\r\n        this.shader = shader;\r\n        const layout = Sketch.wgpu.device.createPipelineLayout({\r\n            bindGroupLayouts: this.bindGroupLayouts\r\n        });\r\n        const vertState = {\r\n            module: shader.vertModule,\r\n            entryPoint: \'main\',\r\n            buffers: [{\r\n                    arrayStride: vertexBuffer.stride,\r\n                    attributes: vertexBuffer.attributeDescriptors\r\n                }]\r\n        };\r\n        const colorState = {\r\n            format: \'bgra8unorm\',\r\n        };\r\n        const fragState = {\r\n            module: shader.fragModule,\r\n            entryPoint: \'main\',\r\n            targets: [colorState]\r\n        };\r\n        const primitiveState = {\r\n            frontFace: \'cw\',\r\n            cullMode: \'front\',\r\n            topology: \'triangle-list\',\r\n        };\r\n        this.depthStencilState = {\r\n            depthWriteEnabled: true,\r\n            depthCompare: "less",\r\n            format: "depth24plus"\r\n        },\r\n            this.pipelineDescriptor = {\r\n                layout: layout,\r\n                vertex: vertState,\r\n                fragment: fragState,\r\n                primitive: primitiveState,\r\n                depthStencil: this.depthStencilState\r\n            };\r\n        this.pipelineNeedsRefresh = true;\r\n        this.vertexBuffers.push(vertexBuffer.getInstance(this.pipelineDescriptor));\r\n        this.pipeline = this.vertexBuffers[0].pipeline;\r\n    }\r\n    setPipelineProps() {\r\n        this.propagate();\r\n    }\r\n    propagate() {\r\n        for (let vertexBuffer of this.vertexBuffers) {\r\n            vertexBuffer.propagatePipeline(this.pipelineDescriptor);\r\n        }\r\n    }\r\n    refreshPipeline() {\r\n        super.refreshPipeline();\r\n        this.propagate();\r\n        this.pipelineNeedsRefresh = false;\r\n    }\r\n    render() {\r\n        const currPass = Sketch.wgpu.currPass;\r\n        const fb = currPass.framebuffer;\r\n        let refresh = false;\r\n        if (this.lastFB !== fb) {\r\n            this.lastFB = fb;\r\n            const pipelineFormat = this.pipelineDescriptor.fragment.targets[0].format;\r\n            const pipelineDepthStencil = this.pipelineDescriptor.depthStencil;\r\n            const passFormat = fb.textures[0].props.format;\r\n            const fbDepthTex = fb.depthTexture;\r\n            if (pipelineFormat !== passFormat) {\r\n                this.pipelineDescriptor.fragment.targets[0].format = passFormat;\r\n                refresh = true;\r\n            }\r\n            if (!fbDepthTex && pipelineDepthStencil) {\r\n                this.pipelineDescriptor.depthStencil = undefined;\r\n                refresh = true;\r\n            }\r\n            else if (fbDepthTex && !pipelineDepthStencil ||\r\n                (pipelineDepthStencil && fbDepthTex && pipelineDepthStencil.format !== fbDepthTex.props.format)) {\r\n                this.depthStencilState.format = fbDepthTex.props.format;\r\n                this.pipelineDescriptor.depthStencil = this.depthStencilState;\r\n                refresh = true;\r\n            }\r\n            if (refresh)\r\n                this.refreshPipeline();\r\n        }\r\n        if (this.pipelineNeedsRefresh || refresh) {\r\n            this.refreshPipeline();\r\n        }\r\n        const passEncoder = currPass.passEncoder;\r\n        let i = 0;\r\n        for (let bindGroup of this.bindGroups) {\r\n            passEncoder.setBindGroup(i, bindGroup);\r\n            i++;\r\n        }\r\n        for (let vb of this.vertexBuffers) {\r\n            vb.draw(passEncoder);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wvertexbuffer.ts\n\r\n\r\n\r\nclass VertexBufferInstance {\r\n    constructor(vb, pipelineDescriptor) {\r\n        this.vb = vb;\r\n    }\r\n    propagatePipeline(pipelineDescriptor) {\r\n        this.pipelineDescriptor = pipelineDescriptor;\r\n        this.pipeline = Sketch.wgpu.device.createRenderPipeline(this.pipelineDescriptor);\r\n    }\r\n    draw(passEncoder) {\r\n        passEncoder.setPipeline(this.pipeline);\r\n        passEncoder.setVertexBuffer(0, this.vb._buff);\r\n        passEncoder.draw(this.vb.vertCnt, 1, 0, 0);\r\n    }\r\n}\r\nclass VertexBuffer extends StorageBuffer {\r\n    constructor({ bufferDataArray, pads }) {\r\n        super();\r\n        this.attributeDescriptors = [];\r\n        this.vertBufferLayouts = [];\r\n        if (pads.length === 0) {\r\n            throw "Need attributes";\r\n        }\r\n        let offsets = [];\r\n        let stride = 0;\r\n        loop(pads.length, i => {\r\n            this.attributeDescriptors.push({\r\n                shaderLocation: i,\r\n                offset: 0,\r\n                format: \'float32x\' + pads[i]\r\n            });\r\n            offsets.push(stride);\r\n            stride += pads[i];\r\n        });\r\n        this.vertCnt = bufferDataArray.length / stride;\r\n        stride *= 4;\r\n        this.create(((bufferDataArray.byteLength + 3) & ~3), GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE, bufferDataArray, true, false);\r\n        this.stride = stride;\r\n        this.pads = pads;\r\n        this.offsets = offsets;\r\n    }\r\n    getInstance(pipelineDescriptor) {\r\n        return new VertexBufferInstance(this, pipelineDescriptor);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wuniformbuffer.ts\n\r\n\r\n\r\n\r\nclass SharedUniformValue {\r\n    constructor(idx) {\r\n        this.idx = idx;\r\n    }\r\n    const(v = 0) {\r\n        this.value = v;\r\n    }\r\n    get value() {\r\n        return this.v;\r\n    }\r\n    set value(v) {\r\n        this.v = v;\r\n    }\r\n}\r\nclass UniformBuffer extends StorageBuffer {\r\n    constructor(maxSz = 1400) {\r\n        super();\r\n        this.sharedUniforms = {};\r\n        (async () => {\r\n            this.create(maxSz * 4, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, null, true, true);\r\n            this._bindGroupLayout = Sketch.wgpu.device.createBindGroupLayout({\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\r\n                        buffer: {\r\n                            type: "uniform"\r\n                        }\r\n                    }\r\n                ]\r\n            });\r\n            this._bindGroup = Sketch.wgpu.device.createBindGroup({\r\n                layout: this._bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: {\r\n                            buffer: this._buff\r\n                        }\r\n                    }\r\n                ]\r\n            });\r\n        })();\r\n    }\r\n    get bindGroupLayout() {\r\n        return this._bindGroupLayout;\r\n    }\r\n    get bindGroup() {\r\n        return this._bindGroup;\r\n    }\r\n    setUniform(name, value) {\r\n        if (!this.sharedUniforms[name]) {\r\n            const idx = Object.keys(this.sharedUniforms).length;\r\n            let uniformVal = new SharedUniformValue(idx);\r\n            uniformVal.value = value;\r\n            this.sharedUniforms[name] = uniformVal;\r\n            if (!isNaN(value)) {\r\n                this.totalFloatSz += 1;\r\n            }\r\n            else if (value instanceof Vec) {\r\n                this.totalFloatSz += 2;\r\n            }\r\n            else if (value instanceof Vector3) {\r\n                this.totalFloatSz += 3;\r\n            }\r\n            else if (value instanceof Vector4) {\r\n                this.totalFloatSz += 4;\r\n            }\r\n            else if (value instanceof Matrix4) {\r\n                this.totalFloatSz += 4 * 4;\r\n            }\r\n            this.mappedArr = new Float32Array(this.totalFloatSz);\r\n        }\r\n        else {\r\n            let uniformVal = this.sharedUniforms[name];\r\n            uniformVal.value = value;\r\n        }\r\n    }\r\n    getUniform(name) {\r\n        const sharedUniform = this.sharedUniforms[name];\r\n        return this.sharedUniforms[sharedUniform.idx].value;\r\n    }\r\n    async update() {\r\n        let padding = 0;\r\n        for (let [key, uniform] of Object.entries(this.sharedUniforms)) {\r\n            if (!isNaN(uniform.value)) {\r\n                this.mappedArr[padding] = uniform.value;\r\n                padding += 1;\r\n            }\r\n            else if (uniform.value instanceof Vec) {\r\n                this.mappedArr[padding] = uniform.value.x;\r\n                this.mappedArr[padding + 1] = uniform.value.y;\r\n                padding += 2;\r\n            }\r\n            else if (uniform.value instanceof Vector3) {\r\n                this.mappedArr[padding] = uniform.value.x;\r\n                this.mappedArr[padding + 1] = uniform.value.y;\r\n                this.mappedArr[padding + 4 * 2] = uniform.value.z;\r\n                padding += 3;\r\n            }\r\n            else if (uniform.value instanceof Vector4) {\r\n                this.mappedArr[padding] = uniform.value.x;\r\n                this.mappedArr[padding + 1] = uniform.value.y;\r\n                this.mappedArr[padding + 2] = uniform.value.z;\r\n                this.mappedArr[padding + 3] = uniform.value.w;\r\n                padding += 4;\r\n            }\r\n            else if (uniform.value instanceof Matrix4) {\r\n                for (let i = 0; i < 4 * 4; i++) {\r\n                    this.mappedArr[padding + i] = uniform.value.elements[i];\r\n                }\r\n                padding += 4 * 4;\r\n            }\r\n        }\r\n        Sketch.wgpu.queue.writeBuffer(this.buff, 0, this.mappedArr.buffer, 0, padding * 4);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wgeom.ts\nconst QuadVerts = new Float32Array([\r\n    -1, -1,\r\n    1, -1,\r\n    -1, 1,\r\n    1, -1,\r\n    1, 1,\r\n    -1, 1,\r\n]);\r\nconst CubeVerts = new Float32Array([\r\n    1, -1, 1, 1, 1, 0, 1, 1, 1, 1,\r\n    -1, -1, 1, 1, 0, 0, 1, 1, 0, 1,\r\n    -1, -1, -1, 1, 0, 0, 0, 1, 0, 0,\r\n    1, -1, -1, 1, 1, 0, 0, 1, 1, 0,\r\n    1, -1, 1, 1, 1, 0, 1, 1, 1, 1,\r\n    -1, -1, -1, 1, 0, 0, 0, 1, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, -1, 1, 1, 1, 0, 1, 1, 0, 1,\r\n    1, -1, -1, 1, 1, 0, 0, 1, 0, 0,\r\n    1, 1, -1, 1, 1, 1, 0, 1, 1, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, -1, -1, 1, 1, 0, 0, 1, 0, 0,\r\n    -1, 1, 1, 1, 0, 1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,\r\n    1, 1, -1, 1, 1, 1, 0, 1, 0, 0,\r\n    -1, 1, -1, 1, 0, 1, 0, 1, 1, 0,\r\n    -1, 1, 1, 1, 0, 1, 1, 1, 1, 1,\r\n    1, 1, -1, 1, 1, 1, 0, 1, 0, 0,\r\n    -1, -1, 1, 1, 0, 0, 1, 1, 1, 1,\r\n    -1, 1, 1, 1, 0, 1, 1, 1, 0, 1,\r\n    -1, 1, -1, 1, 0, 1, 0, 1, 0, 0,\r\n    -1, -1, -1, 1, 0, 0, 0, 1, 1, 0,\r\n    -1, -1, 1, 1, 0, 0, 1, 1, 1, 1,\r\n    -1, 1, -1, 1, 0, 1, 0, 1, 0, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    -1, 1, 1, 1, 0, 1, 1, 1, 0, 1,\r\n    -1, -1, 1, 1, 0, 0, 1, 1, 0, 0,\r\n    -1, -1, 1, 1, 0, 0, 1, 1, 0, 0,\r\n    1, -1, 1, 1, 1, 0, 1, 1, 1, 0,\r\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n    1, -1, -1, 1, 1, 0, 0, 1, 1, 1,\r\n    -1, -1, -1, 1, 0, 0, 0, 1, 0, 1,\r\n    -1, 1, -1, 1, 0, 1, 0, 1, 0, 0,\r\n    1, 1, -1, 1, 1, 1, 0, 1, 1, 0,\r\n    1, -1, -1, 1, 1, 0, 0, 1, 1, 1,\r\n    -1, 1, -1, 1, 0, 1, 0, 1, 0, 0,\r\n]);\r\n\n;// CONCATENATED MODULE: ./src/utils/wcompute.ts\n\r\n\r\n\r\n\r\n\r\n\r\nclass ComputeProgram extends AbstractBindingContainer {\r\n    constructor({ compString, buffer }) {\r\n        super();\r\n        this.computeShader = new ShaderCompute(compString);\r\n        this.pipelineDescriptor = {\r\n            compute: {\r\n                module: this.computeShader.compModule,\r\n                entryPoint: "main"\r\n            }\r\n        };\r\n        this.pipelineNeedsRefresh = true;\r\n        this.boundBuffer = buffer;\r\n        if (this.boundBuffer) {\r\n            this.setBuffer(this.boundBuffer);\r\n        }\r\n        this.computePassDescriptor = {};\r\n    }\r\n    setBuffer(buffer) {\r\n        this.boundBuffer = buffer;\r\n        if (buffer instanceof Texture) {\r\n            this.setWritable(buffer, 9);\r\n        }\r\n    }\r\n    runBound({ endLastPass }) {\r\n        if (false) {}\r\n        if (this.boundBuffer instanceof Texture) {\r\n            this.runTex({ endLastPass, texture: this.boundBuffer });\r\n        }\r\n    }\r\n    runTex({ endLastPass, texture }) {\r\n        const workGroupSz = new Vector3([Math.ceil(texture.width / 16), Math.ceil(texture.height / 16), 1]);\r\n        this.runSz({ endLastPass, workGroupSz });\r\n    }\r\n    runBuffer({ endLastPass, buffer }) {\r\n        const workGroupSz = new Vector3([Math.ceil(buffer.mappedArr.length / 256), 1, 1]);\r\n        this.runSz({ endLastPass, workGroupSz });\r\n    }\r\n    runSz({ endLastPass, workGroupSz }) {\r\n        endLastPass = ifExistsAElseB(endLastPass, true);\r\n        if (endLastPass) {\r\n            Sketch.wgpu.flushPasses();\r\n        }\r\n        if (this.pipelineNeedsRefresh) {\r\n            this.refreshPipeline();\r\n        }\r\n        this.commandEncoder = Sketch.wgpu.device.createCommandEncoder();\r\n        this.passEncoder = this.commandEncoder.beginComputePass(this.computePassDescriptor);\r\n        Sketch.wgpu.encoderPasses.push({\r\n            commandEncoder: this.commandEncoder,\r\n            passEncoder: this.passEncoder,\r\n        });\r\n        let i = 0;\r\n        for (let bindGroup of this.bindGroups) {\r\n            this.passEncoder.setBindGroup(i, bindGroup);\r\n            i++;\r\n        }\r\n        this.passEncoder.setPipeline(this.pipeline);\r\n        this.passEncoder.dispatchWorkgroups(workGroupSz.x, workGroupSz.y, workGroupSz.z);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wgpu.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass WrightGPU {\r\n    constructor(canvas) {\r\n        this.encoderPasses = [];\r\n        this.canvas = canvas;\r\n    }\r\n    get currPass() { return this.encoderPasses[this.encoderPasses.length - 1]; }\r\n    async flushPasses() {\r\n        if (Sketch.wgpu.encoderPasses.length > 0) {\r\n            let commandBuffers = [];\r\n            for (let pass of Sketch.wgpu.encoderPasses) {\r\n                if (pass.passEncoder)\r\n                    pass.passEncoder.end();\r\n                commandBuffers.push(pass.commandEncoder.finish());\r\n            }\r\n            this.encoderPasses = [];\r\n            Sketch.wgpu.queue.submit(commandBuffers);\r\n        }\r\n    }\r\n    async initializeGPU(args) {\r\n        args = ifExistsAElseB(args, {});\r\n        this.width = this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;\r\n        this.height = this.canvas.height = this.canvas.clientHeight * window.devicePixelRatio;\r\n        this.gpu = navigator.gpu;\r\n        this.adapter = await this.gpu.requestAdapter();\r\n        this.device = await this.adapter.requestDevice();\r\n        this.queue = this.device.queue;\r\n        this.context = this.canvas.getContext(\'webgpu\');\r\n        if (!this.adapter || !this.device) {\r\n            window.alert("Error in adapter or device setup.");\r\n            return;\r\n        }\r\n        this.context.configure({\r\n            device: this.device,\r\n            format: "bgra8unorm",\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\r\n            alphaMode: "opaque"\r\n        });\r\n        const defaultTex = this.context.getCurrentTexture();\r\n        const defaultTexView = defaultTex.createView();\r\n        this.defaultFramebuffer = Object.create(FrameBuffer.prototype);\r\n        const depthTex = new Texture({ depthTex: true, framebuffer: this.defaultFramebuffer });\r\n        const wDefaultTex = Object.create(Texture.prototype);\r\n        wDefaultTex.texture = defaultTex;\r\n        wDefaultTex.view = defaultTexView;\r\n        wDefaultTex.width = this.width;\r\n        wDefaultTex.height = this.height;\r\n        wDefaultTex.depth = 1;\r\n        wDefaultTex.defaultTex = true;\r\n        wDefaultTex.props = {\r\n            depthTex: true,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n            format: \'bgra8unorm\'\r\n        };\r\n        Texture.textures.push(wDefaultTex);\r\n        this.defaultFramebuffer.textures = [wDefaultTex];\r\n        this.defaultFramebuffer.depthTexture = depthTex;\r\n        wDefaultTex.attachedFramebuffers = [this.defaultFramebuffer];\r\n        const defaultFbRPDescriptor = {\r\n            colorAttachments: [\r\n                {\r\n                    view: defaultTexView,\r\n                    clearValue: { r: 0.5, g: 0.1, b: 0.1, a: 0.5 },\r\n                    loadOp: "clear",\r\n                    storeOp: "store",\r\n                }\r\n            ],\r\n            depthStencilAttachment: {\r\n                view: depthTex.view,\r\n                depthClearValue: 1,\r\n                depthLoadOp: "clear",\r\n                depthStoreOp: \'store\',\r\n            }\r\n        };\r\n        this.defaultFramebuffer.renderPassDescriptor = defaultFbRPDescriptor;\r\n    }\r\n    getPassThroughVert() {\r\n        return (__webpack_require__(431)/* ["default"] */ .Z);\r\n    }\r\n    getFullScreenQuadVert() {\r\n        return (__webpack_require__(115)/* ["default"] */ .Z);\r\n    }\r\n}\r\nclass ShaderCompute {\r\n    constructor(compString) {\r\n        compString = ShaderImports + compString;\r\n        this.compModule = Sketch.wgpu.device.createShaderModule({ code: compString });\r\n    }\r\n}\r\nclass Shader {\r\n    constructor(vertString, fragString) {\r\n        vertString = ShaderImports + vertString;\r\n        fragString = ShaderImports + fragString;\r\n        this.vertModule = Sketch.wgpu.device.createShaderModule({ code: vertString }),\r\n            this.fragModule = Sketch.wgpu.device.createShaderModule({ code: fragString });\r\n    }\r\n}\r\nconst ShaderImports = `\r\n  type iv4 = vec4<i32>;\r\n  type iv3 = vec3<i32>;\r\n  type iv2 = vec2<i32>;\r\n\r\n  type uv4 = vec4<u32>;\r\n  type uv3 = vec3<u32>;\r\n  type uv2 = vec2<u32>;\r\n\r\n  type v4 = vec4<f32>;\r\n  type v3 = vec3<f32>;\r\n  type v2 = vec2<f32>;\r\n  type m2 = mat2x2<f32>;\r\n  type m3 = mat3x3<f32>;\r\n  type m4 = mat4x4<f32>;\r\n  type float = f32;\r\n\r\n  type int = i32;\r\n  type uint = u32;\r\n\r\n  struct Camera {\r\n    view: m4,\r\n    proj: m4,\r\n    invView: m4,\r\n    pos: v3,\r\n    near: float,\r\n    far: float,\r\n  }\r\n\r\n  @group(0) @binding(1)\r\n  var<uniform> cam: Camera;\r\n\r\n  struct UBO {\r\n    resolution: v2,\r\n    time: float,\r\n    deltaTime: float,\r\n    frame: float,\r\n    mouse: v4,\r\n  }\r\n  @group(0) @binding(0)\r\n  var<uniform> u: UBO;\r\n\r\n  fn rot(a: float)-> m2{\r\n    return m2(\r\n      cos(a), -sin(a),\r\n      sin(a), cos(a)\r\n    );\r\n  }\r\n\r\n  fn rotX3(a: float) -> m3{\r\n    let r = rot(a);\r\n\r\n    return m3(\r\n      1.,0.,0.,\r\n      0.,r[0][0],r[0][1],\r\n      0.,r[1][0],r[1][1]\r\n    );\r\n  }\r\n\r\n  fn rotY3(a: float) -> m3{\r\n    let r = rot(a);\r\n\r\n    return m3(\r\n      r[0][0],0.,r[0][1],\r\n      0.,1.,0.,\r\n      r[1][0],0.,r[1][1]\r\n    );\r\n  }\r\n\r\n  fn rotZ3(a: float) -> m3{\r\n    let r = rot(a);\r\n\r\n    return m3(\r\n      r[0][0],r[0][1],0.,\r\n      r[1][0],r[1][1],0.,\r\n      0.,0.,1.\r\n    );\r\n  }\r\n\r\n\r\n  \r\n\r\n  // @group(3) @binding(9)\r\n  // var<storage, write> tex: array<float>;\r\n`;\r\n\n;// CONCATENATED MODULE: ./src/utils/wutils.ts\nclass wutils_Clock {\r\n    constructor() {\r\n        this._deltaTime = 0;\r\n        this._time = 0;\r\n        this._startTime = 0;\r\n        this._frame = 0;\r\n        this._time = this._startTime = new Date().getTime() / 1000;\r\n    }\r\n    get time() { return this._time; }\r\n    get deltaTime() { return this._deltaTime; }\r\n    get frame() { return this._frame; }\r\n    tick() {\r\n        const lastTime = this._time;\r\n        this._time = new Date().getTime() / 1000. - this._startTime;\r\n        this._deltaTime = this._time - lastTime;\r\n        this._frame++;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wbindgroup.ts\n\r\n\r\n\r\n\r\nclass BindGroup {\r\n    constructor(groups) {\r\n        this.elements = [];\r\n        this.elements = groups;\r\n        this.rebuild();\r\n    }\r\n    get bindGroupLayout() {\r\n        return this._bindGroupLayout;\r\n    }\r\n    get bindGroup() {\r\n        return this._bindGroup;\r\n    }\r\n    rebuild() {\r\n        const bindGroupEntries = [];\r\n        const bindGroupLayoutEntries = [];\r\n        let i = 0;\r\n        for (let element of this.elements) {\r\n            if (element instanceof Texture) {\r\n            }\r\n            else if (element instanceof StorageBuffer) {\r\n                bindGroupEntries.push({\r\n                    binding: i,\r\n                    resource: {\r\n                        buffer: element.buff\r\n                    }\r\n                });\r\n                bindGroupLayoutEntries.push({\r\n                    binding: i,\r\n                    visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,\r\n                    buffer: {\r\n                        type: element instanceof UniformBuffer ? "uniform" : "storage"\r\n                    }\r\n                });\r\n            }\r\n            i++;\r\n        }\r\n        this._bindGroupLayout = Sketch.wgpu.device.createBindGroupLayout({\r\n            entries: bindGroupLayoutEntries\r\n        });\r\n        this._bindGroup = Sketch.wgpu.device.createBindGroup({\r\n            layout: this._bindGroupLayout,\r\n            entries: bindGroupEntries\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/common.js\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== \'undefined\' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/mat4.js\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction create() {\n  var out = new ARRAY_TYPE(16);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL\'s clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = (/* unused pure expression or super */ null && (perspectiveNO));\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal\'s clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL\'s clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = (/* unused pure expression or super */ null && (orthoNO));\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal\'s clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4\'s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix\'s elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4\'s after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b\'s elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction mat4_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mul = (/* unused pure expression or super */ null && (multiply));\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar sub = (/* unused pure expression or super */ null && (subtract));\n;// CONCATENATED MODULE: ./node_modules/gl-matrix/esm/vec3.js\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_create() {\n  var out = new ARRAY_TYPE(3);\n\n  if (ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction vec3_length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction vec3_fromValues(x, y, z) {\n  var out = new ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction vec3_copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction vec3_set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction vec3_ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction vec3_floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction vec3_max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction vec3_scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3\'s after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3\'s\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3\'s\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3\'s\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3\'s\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction vec3_lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly \'1\'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction vec3_rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction vec3_str(a) {\n  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction vec3_equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar vec3_sub = (/* unused pure expression or super */ null && (vec3_subtract));\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar vec3_mul = (/* unused pure expression or super */ null && (vec3_multiply));\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar div = (/* unused pure expression or super */ null && (divide));\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar dist = (/* unused pure expression or super */ null && (distance));\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar sqrDist = (/* unused pure expression or super */ null && (squaredDistance));\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar len = (/* unused pure expression or super */ null && (vec3_length));\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar sqrLen = (/* unused pure expression or super */ null && (squaredLength));\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = vec3_create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n;// CONCATENATED MODULE: ./src/utils/wcamera.ts\n\r\n\r\n\r\n\r\nclass AbstractCamera {\r\n    constructor() {\r\n        this.position = new Vector3([0.01, 0., -10]);\r\n        this.fov = 100;\r\n        this.near = 0.001;\r\n        this.far = 1000;\r\n    }\r\n}\r\nvar CameraType;\r\n(function (CameraType) {\r\n    CameraType[CameraType["Orthographic"] = 0] = "Orthographic";\r\n    CameraType[CameraType["Perspective"] = 1] = "Perspective";\r\n})(CameraType || (CameraType = {}));\r\nclass Camera extends AbstractCamera {\r\n    constructor() {\r\n        super();\r\n        this.pilot = false;\r\n        this.sphericalCoords = new Vec(0.01, 0.01);\r\n        this.forwardDir = new Vec3(0, 0, 0);\r\n        this.target = new Vector3([0.01, 0.001, 0.001]);\r\n        this.cameraType = CameraType.Perspective;\r\n        this.update();\r\n    }\r\n    update() {\r\n        if (this.pilot) {\r\n            const mouseSpeed = 0.125;\r\n            if (Sketch.io.mouse.down)\r\n                this.sphericalCoords = this.sphericalCoords.add(new Vec(Sketch.io.deltaMouseNdc.v[0] * mouseSpeed * Sketch.clock.deltaTime, Sketch.io.deltaMouseNdc.v[1] * mouseSpeed * Sketch.clock.deltaTime));\r\n            this.forwardDir = new Vec3(0, 0, 1);\r\n            const pitch = this.sphericalCoords.x;\r\n            const yaw = this.sphericalCoords.y;\r\n            this.forwardDir = this.forwardDir.rot(yaw * tau, \'x\');\r\n            this.forwardDir = this.forwardDir.rot(-pitch * tau, \'y\');\r\n            this.forwardDir = this.forwardDir.normalize();\r\n            const forwardDir = new Vec3(this.forwardDir.v[0], this.forwardDir.v[1], this.forwardDir.v[2]);\r\n            const rightDir = new Vec3(0, 1, 0).cross(this.forwardDir);\r\n            const upDir = this.forwardDir.cross(rightDir);\r\n            let walkSpeed = 10;\r\n            let walkVector = new Vec3(0, 0, 0);\r\n            if (Sketch.io.getKeyDown("KeyW")) {\r\n                walkVector = walkVector.add(forwardDir.mul(walkSpeed));\r\n            }\r\n            if (Sketch.io.getKeyDown("KeyS")) {\r\n                walkVector = walkVector.add(forwardDir.mul(-walkSpeed));\r\n            }\r\n            if (Sketch.io.getKeyDown("KeyQ")) {\r\n                walkVector = walkVector.add(upDir.mul(walkSpeed));\r\n            }\r\n            if (Sketch.io.getKeyDown("KeyE")) {\r\n                walkVector = walkVector.add(upDir.mul(-walkSpeed));\r\n            }\r\n            if (Sketch.io.getKeyDown("KeyA")) {\r\n                walkVector = walkVector.add(rightDir.mul(walkSpeed));\r\n            }\r\n            if (Sketch.io.getKeyDown("KeyD")) {\r\n                walkVector = walkVector.add(rightDir.mul(-walkSpeed));\r\n            }\r\n            walkVector = walkVector.mul(Sketch.clock.deltaTime);\r\n            this.position = this.position.add(new Vector3([walkVector.x, walkVector.y, walkVector.z]));\r\n            this.target.x = this.position.x + this.forwardDir.v[0];\r\n            this.target.y = this.position.y + this.forwardDir.v[1];\r\n            this.target.z = this.position.z + this.forwardDir.v[2];\r\n        }\r\n        if (this.cameraType === CameraType.Perspective) {\r\n            this.projMatrix = Matrix4.perspective(this.fov, this.near, this.far);\r\n            this.viewMatrix = Matrix4.lookAt(this.position, this.target);\r\n            this.inverseViewMatrix = this.viewMatrix.inverse.transpose;\r\n            const viewMatrix = create();\r\n            lookAt(viewMatrix, vec3_fromValues(this.position.x, this.position.y, this.position.z), vec3_fromValues(this.target.x, this.target.y, this.target.z), vec3_fromValues(0, 1, 0));\r\n            viewMatrix.forEach((v, i) => {\r\n                this.viewMatrix.elements[i] = v;\r\n            });\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/wio.ts\n\r\n\r\nclass IO {\r\n    constructor() {\r\n        this.keys = new Map();\r\n        this.mousePrevFrame = { x: 0, y: 0, down: false, click: false, xNdc: 0, yNdc: 0, };\r\n        this.mouse = { x: 0, y: 0, down: false, click: false, xNdc: 0, yNdc: 0, };\r\n        this.deltaMouseNdc = new Vec(0, 0);\r\n        this.mouseState = { x: 0, y: 0, down: false, click: false, xNdc: 0, yNdc: 0 };\r\n        this.pointerLocked = false;\r\n        window.addEventListener(\'keydown\', (ev) => {\r\n            this.keys[ev.code] = { down: true };\r\n        });\r\n        window.addEventListener(\'keyup\', (ev) => {\r\n            this.keys[ev.code] = { down: false };\r\n        });\r\n        window.addEventListener("pointermove", (e) => {\r\n            if (this.pointerLocked) {\r\n                this.mouseState.x += e.movementX;\r\n                this.mouseState.y += e.movementY;\r\n                this.mouseState.xNdc = (this.mouseState.x / Sketch.wgpu.width) * 2 - 1;\r\n                this.mouse.yNdc = -(this.mouseState.y / Sketch.wgpu.height) * 2 + 1;\r\n            }\r\n            else {\r\n                this.mouseState.x = e.clientX;\r\n                this.mouseState.y = e.clientY;\r\n                this.mouseState.xNdc = (e.clientX / Sketch.wgpu.width) * 2 - 1;\r\n                this.mouse.yNdc = -(e.clientY / Sketch.wgpu.height) * 2 + 1;\r\n            }\r\n        });\r\n        window.addEventListener("mousedown", async () => {\r\n            this.mouseState.down = true;\r\n            this.mouseState.click = true;\r\n            if (Sketch.camera.pilot) {\r\n                this.pointerLocked = true;\r\n                await Sketch.wgpu.canvas.requestPointerLock();\r\n            }\r\n        });\r\n        window.addEventListener("mouseup", (e) => {\r\n            this.mouseState.down = false;\r\n            if (Sketch.camera.pilot) {\r\n                document.exitPointerLock();\r\n            }\r\n        });\r\n        document.addEventListener(\'pointerlockchange\', () => { }, false);\r\n    }\r\n    async update() {\r\n        const tempMouse = this.mousePrevFrame;\r\n        this.mousePrevFrame = this.mouse;\r\n        this.mouse = tempMouse;\r\n        for (let [key, value] of Object.entries(this.mouseState)) {\r\n            this.mouse[key] = value;\r\n        }\r\n        this.deltaMouseNdc.v[0] = (this.mouse.x - this.mousePrevFrame.x);\r\n        this.deltaMouseNdc.v[1] = (this.mouse.y - this.mousePrevFrame.y);\r\n        this.mouseState.click = false;\r\n    }\r\n    getKeyDown(code) {\r\n        try {\r\n            return this.keys[code].down;\r\n        }\r\n        catch (ignore) {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/index.ts\n__webpack_require__(280);\r\nlet Stats;\r\nif (false) {}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Sketch {\r\n    constructor() {\r\n        this.callbacks = [];\r\n        this.init = async () => {\r\n            await Sketch.wgpu.initializeGPU();\r\n            Sketch.sharedBindGroup = new BindGroup([\r\n                Sketch.sharedUBO = new UniformBuffer(),\r\n                Sketch.cameraUBO = new UniformBuffer(),\r\n            ]);\r\n            this.setup();\r\n            const texResx = this.width;\r\n            const texResy = this.height;\r\n            const texArr = [];\r\n            for (let i = 0; i < texResy; i++) {\r\n                const rowArr = [];\r\n                for (let i = 0; i < texResx; i++) {\r\n                    rowArr.push(new Vector4([1, 0, 0, 1]));\r\n                }\r\n                texArr.push(rowArr);\r\n            }\r\n            const tex = new Texture({ format: "rgba8unorm" });\r\n            const canvasFb = new FrameBuffer({ depth: true, format: "rgba8unorm" });\r\n            const particleCnt = 100000;\r\n            const particleBuff = new StorageBuffer().create(particleCnt);\r\n            const histogramBuff = new StorageBuffer().create(this.width * this.height);\r\n            particleBuff.mappedArr.forEach((val, idx) => {\r\n                particleBuff.mappedArr[idx] = 0;\r\n            });\r\n            histogramBuff.mappedArr.forEach((val, idx) => {\r\n                histogramBuff.mappedArr[idx] = 0;\r\n            });\r\n            particleBuff.uploadMapped();\r\n            histogramBuff.uploadMapped();\r\n            const uniBuffTest = new UniformBuffer();\r\n            uniBuffTest.setUniform("a", 1);\r\n            uniBuffTest.setUniform("b", 0);\r\n            uniBuffTest.setUniform("c", 1);\r\n            uniBuffTest.setUniform("d", 0);\r\n            uniBuffTest.setUniform("e", 1);\r\n            await uniBuffTest.update();\r\n            const quadBuff = new VertexBuffer({ bufferDataArray: QuadVerts, pads: [2] });\r\n            const postQuad = new Thing(quadBuff, new Shader(Sketch.wgpu.getFullScreenQuadVert(), `\r\n\r\n      @group(3) @binding(0)\r\n      var<storage, read_write> histogram: array<float>;\r\n\r\n      @group(3) @binding(1)\r\n      var<storage, read_write> particle: array<float>;\r\n\r\n      // @group(1) @binding(0)\r\n      // var<uniform> unibuff: array<float,10>;\r\n\r\n      // @group(2) @binding(0)\r\n      // var tSampler: sampler;\r\n\r\n      // @group(2) @binding(1)\r\n      // var tex: texture_2d<f32>;\r\n\r\n      @fragment\r\n      fn main(\r\n        @builtin(position) U: v4,\r\n        @location(0) uv: v2,\r\n        // @location(0) inCol: v4\r\n        ) -> @location(0) v4 {\r\n        var uvn = uv*0.5 + 0.5;\r\n\r\n        var res = u.resolution.xy;\r\n        var arrIdx = uint(U.x) + uint(U.y)*uint(res.x);\r\n\r\n        var histoTap = histogram[arrIdx];\r\n\r\n        let h = histoTap;\r\n\r\n        histoTap = 1.-exp(-abs(histoTap)*0.04);\r\n\r\n        var col = v4(sin(vec3(3- h*0.002,2 ,1)+(1.-histoTap)*2.007 + -0.2 + sin(u.time)*0.2)*0.5 + 0.5,1.);\r\n        col *= histoTap*1.;\r\n        col[3] = 1.;\r\n        col = 1.- col;\r\n        \r\n        //col[2] = U.x/res.x;\r\n        // var col = v4(histogram[uint(abs(uv.x*20.))%100u]*1.,0.,0.,1.);\r\n        // col.w = 1.;\r\n\r\n        // col = fract(U.xyxy/100.);\r\n        \r\n        return col;\r\n      }`));\r\n            postQuad.setWritables([histogramBuff, particleBuff]);\r\n            const cubeBuff = new VertexBuffer({ bufferDataArray: CubeVerts, pads: [4, 4, 2] });\r\n            const cubeShader = new Shader(Sketch.wgpu.getPassThroughVert(), `\r\n      @group(2) @binding(0)\r\n      var tSampler: sampler;\r\n\r\n      @group(2) @binding(1)\r\n      var tex: texture_2d<f32>;\r\n\r\n      @fragment\r\n      fn main(\r\n        @builtin(position) U: v4,\r\n        @location(0) inCol: v4\r\n        ) -> @location(0) v4 {\r\n        var col = inCol;\r\n        var uv = fract(U.xy/u.resolution);\r\n\r\n        col = textureSample(tex, tSampler, uv);\r\n\r\n        // col = v4(1.,1.,1.,1.);\r\n\r\n        if(sin(u.time*20.) > 0.){\r\n          // col.x = 1.;\r\n        }\r\n        \r\n        return col;\r\n        // return v4(0.,1.,0.,1.);\r\n      }\r\n    `);\r\n            const cubeThing = new Thing(cubeBuff, cubeShader);\r\n            cubeThing.setTexture(tex, 1);\r\n            const computePass = new ComputeProgram({\r\n                compString: `\r\n      \r\n        fn IH(_a: int) -> int{\r\n            var a = _a;\r\n            a=(a^61)^(a>>16u);\r\n            a=a+(a<<3u);\r\n            a=a^(a>>4u);\r\n            a=a*0x27d4eb2d;\r\n            a=a^(a>>15u);\r\n            return a;\r\n        }\r\n\r\n        fn H(_a: int) -> float{\r\n            var a = _a;\r\n            a=(a^61)^(a>>16u);\r\n            a=a+(a<<3u);\r\n            a=a^(a>>4u);\r\n            a=a*0x27d4eb2d;\r\n            a=a^(a>>15u);\r\n            return float(a)/float(0x7FFFFFFF);\r\n        }\r\n\r\n        fn rand2(a: int) -> v2{\r\n            return vec2(H(a^0x348593),\r\n            H(a^0x8593D5));\r\n        }\r\n\r\n        fn randn(randuniform: v2) -> v2{\r\n            var r = randuniform;\r\n            r.x = sqrt(-2.*log(1e-9+abs(r.x)));\r\n            r.y = r.y*6.28318;\r\n            r = r.x*vec2(cos(r.y),sin(r.y));\r\n            return r;\r\n        }\r\n        fn randc(randuniform: v2) -> v2{\r\n            var r=randuniform;\r\n            r.x=sqrt(r.x);\r\n            r.y=r.y*6.28318;\r\n            r=r.x*vec2(cos(r.y),sin(r.y));\r\n            return r;\r\n        }\r\n\r\n        fn S(x: v3) -> v3{\r\n          return vec3(x/(1e-6+dot(x.xyz,x.xyz)));\r\n        }\r\n        \r\n        fn hash31(p: float)->v3{\r\n          var p3 = fract(v3(p,p,p) * v3(.1031, .1030, .0973));\r\n          p3 += dot(p3, p3.yzx+33.33);\r\n          return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n        }\r\n\r\n\r\n        fn projParticle(_p: v3) -> v3{\r\n          var p = _p;\r\n\r\n          // let m = rot(u.time);\r\n          \r\n          // let rr = p.xy * m;\r\n\r\n          // p *= rotY3(u.time*0.3 + sin(u.time*0.3)*0.8);\r\n          // p *= rotZ3( 0. + sin(u.time)*0.5 );\r\n\r\n          // p.z += 15.;\r\n          // p.x += 0.5;\r\n          // p.y -= 2.5;\r\n          // p *= 1.;\r\n          //p.z += 1.;\r\n          p *= 2.;\r\n\r\n\r\n          var o = (cam.proj*cam.view*vec4(p.x,p.y,p.z,1.));\r\n          o /= o.w;\r\n\r\n          let z = o.z;\r\n\r\n          p = o.xyz;\r\n\r\n          // p.z = z;\r\n\r\n          //q.z = p.z;\r\n\r\n          //var q = vec4(cam.proj*cam.view*v4(p,1.));\r\n          //q = q/q.w;\r\n          return p;\r\n        }\r\n\r\n        @group(3) @binding(0)\r\n        var<storage, read_write> histogram: array<float>;\r\n        @group(3) @binding(1)\r\n        var<storage, read_write> particle: array<float>;\r\n\r\n        @compute\r\n        @workgroup_size(256,1,1)\r\n\r\n        fn main(\r\n          @builtin(workgroup_id) wkId: uv3,\r\n          @builtin(global_invocation_id) id: uv3,\r\n        ){\r\n          let fid = v3(id);\r\n          let iid = iv2(id.xy);\r\n\r\n          let particleIdx = iid.x + iid.x * iid.y;\r\n          let floatId = float(iid.x + iid.x * iid.y);\r\n\r\n          let iters = 140;\r\n          var res = u.resolution.xy;\r\n          //res[0] = u.resolution[0];\r\n          //res[1] = u.resolution[1];\r\n\r\n          var p = sin(v3(0.4,0.1 + floatId*sin(0.2*floatId),0.6)*floatId + u.time);\r\n          p += 0.;\r\n          p *= .4;\r\n\r\n          p = hash31(float(particleIdx)*0.02);\r\n\r\n          //var p = v3(0.,0.,0.);\r\n\r\n          //p *= res.xyy;\r\n          var env = u.time + sin(u.time);\r\n          var envb = sin(u.time*0.45);\r\n\r\n          // env *= 0.;\r\n          // envb *= 0.;\r\n\r\n          for(var i = 0; i < iters; i++){\r\n            let seed = particleIdx*10000000 + i*100;\r\n\r\n            let r = H(seed);\r\n\r\n\r\n            if(r<.3){\r\n              p = p + 4.3 + envb;\r\n              p *= rotX3(env*0.2);\r\n              p = p/clamp(dot(p,p),-0.2,4.);\r\n            } else if(r<.66){\r\n              // p.xz *= rot(5.2+ sin(particleIdx*0.00001)*0.001);\r\n              // p.yz *= rot(5.2);\r\n              p = p+vec3(-1.,0.4,0.);\r\n              p = p/clamp(dot(-p,p),-3.2,1.);\r\n              p = p*vec3(2.,1.5,1.2)*1.5;\r\n            }\r\n            else {\r\n              p = p - v3(-0.2,0.2,0.2);\r\n              p = p/clamp(dot(p,p),-4.5,10.);\r\n              p = p*vec3(2.,1.5,1.2)*3.1;\r\n            }\r\n\r\n            var q = projParticle(p);\r\n            // let uv = q.xy/2. + 0.5;\r\n            let uv = q.xy/2. + 0.5;\r\n            let cc = iv2(uv.xy*res.x);\r\n\r\n            let arrIdx = cc.x + cc.y*int(res.x);\r\n\r\n            if ( q.z < 1. && uv.x > 0. && uv.x < 1. && uv.y > 0. && uv.y < 1.){\r\n            // if ( q.z < 1. && arrIdx > 0 && arrIdx < int(res.x*res.y)){\r\n                histogram[arrIdx] += 1.;\r\n              }\r\n            }\r\n          }\r\n\r\n        \r\n      `,\r\n            });\r\n            computePass.setWritables([histogramBuff, particleBuff]);\r\n            this.render = async () => {\r\n                Sketch.wgpu.defaultFramebuffer.textures[0].texture = Sketch.wgpu.context.getCurrentTexture();\r\n                Sketch.wgpu.defaultFramebuffer.renderPassDescriptor.colorAttachments[0].view =\r\n                    Sketch.wgpu.defaultFramebuffer.textures[0].view =\r\n                        Sketch.wgpu.context.getCurrentTexture().createView();\r\n                tex.clear(new Vector4([0, 0, 1, 1]));\r\n                histogramBuff.clear(true);\r\n                computePass.runBuffer({ endLastPass: true, buffer: particleBuff });\r\n                await Sketch.wgpu.flushPasses();\r\n                Sketch.wgpu.defaultFramebuffer.startPass();\r\n                postQuad.render();\r\n                await Sketch.wgpu.flushPasses();\r\n            };\r\n            this.updateShit = async () => {\r\n            };\r\n        };\r\n        this.setup = async () => {\r\n            window.addEventListener("resize", () => this.onWindowResize(), false);\r\n            if (false) {}\r\n            this.updateSharedUniforms();\r\n        };\r\n        const canvas = document.createElement("canvas");\r\n        canvas.id = "canvas";\r\n        document.body.appendChild(canvas);\r\n        Sketch.camera = new Camera();\r\n        Sketch.camera.pilot = true;\r\n        Sketch.clock = new wutils_Clock();\r\n        Sketch.io = new IO();\r\n        Sketch.wgpu = new WrightGPU(canvas);\r\n    }\r\n    get width() { return Sketch.wgpu.width; }\r\n    get height() { return Sketch.wgpu.height; }\r\n    async updateSharedUniforms() {\r\n        Sketch.sharedUBO.setUniform("resolution", new Vec(this.width, this.height));\r\n        Sketch.sharedUBO.setUniform("time", Sketch.clock.time);\r\n        Sketch.sharedUBO.setUniform("deltaTime", Sketch.clock.deltaTime);\r\n        Sketch.sharedUBO.setUniform("frame", Sketch.clock.frame);\r\n        Sketch.sharedUBO.setUniform("mouse", new Vector4([Sketch.io.mouse.x, Sketch.io.mouse.y, Number(Sketch.io.mouse.down), Number(Sketch.io.mouse.click)]));\r\n        Sketch.sharedUBO.update();\r\n        Sketch.cameraUBO.setUniform("view", Sketch.camera.viewMatrix);\r\n        Sketch.cameraUBO.setUniform("projection", Sketch.camera.projMatrix);\r\n        Sketch.cameraUBO.setUniform("inverseView", Sketch.camera.inverseViewMatrix);\r\n        Sketch.cameraUBO.setUniform("position", Sketch.camera.position);\r\n        Sketch.cameraUBO.setUniform("near", Sketch.camera.near);\r\n        Sketch.cameraUBO.setUniform("far", Sketch.camera.far);\r\n        Sketch.cameraUBO.update();\r\n    }\r\n    async animate() {\r\n        Sketch.clock.tick();\r\n        if (false)\r\n            {}\r\n        Sketch.camera.update();\r\n        await Sketch.io.update();\r\n        this.updateSharedUniforms();\r\n        this.updateShit();\r\n        for (let callback of this.callbacks) {\r\n            callback();\r\n        }\r\n        this.render();\r\n        requestAnimationFrame(() => this.animate());\r\n    }\r\n    onWindowResize() {\r\n        const prevWidth = Sketch.wgpu.width;\r\n        const prevHeight = Sketch.wgpu.height;\r\n        Sketch.wgpu.width = Sketch.wgpu.canvas.width = Sketch.wgpu.canvas.clientWidth * window.devicePixelRatio;\r\n        Sketch.wgpu.height = Sketch.wgpu.canvas.height = Sketch.wgpu.canvas.clientHeight * window.devicePixelRatio;\r\n        for (let texture of Texture.textures) {\r\n            if (texture.height === prevHeight && texture.width === prevWidth || texture.defaultTex) {\r\n                texture.resize(this.width, this.height);\r\n            }\r\n        }\r\n    }\r\n}\r\n(async () => {\r\n    const sketch = new Sketch();\r\n    await sketch.init();\r\n    sketch.animate();\r\n})();\r\n\n\n//# sourceURL=webpack://webgpufw/./src/index.ts_+_20_modules?')}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={id:n,exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=n=>{var t=n&&n.t?()=>n.default:()=>n;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{i:1,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"t",{value:1})};var __webpack_exports__=__webpack_require__(42)})();